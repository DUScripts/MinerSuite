{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"onMinerSync(message)","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"onReceived(channel,message)","slotKey":"9"},"key":"0"},{"code":"onStop()","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"1"},{"code":"---\n--- Created by Zrips.\n--- DateTime: 2023-01-02 14:06\n---\n\nflowerName = \"Example\" --export: This flower name. Keep \" at front and end\nemitterChannel = \"SuperSecretChannel\" --export: Channel name. Keep \" at front and end\nhub = 192000 --export: Hub size if in use\n\nminingUnits = {}\nminingUnitsData = {}\ncontainer = {}\n\nores = {}\n\nreceiver = nil\ntransmitter = nil\n\nfunction getMaxVolume()\n    local max = container.container.getMaxVolume()\n    if max and max > 0 then\n        return max\n    end\n    return ContainerMaxVol(container.container.getMaxHitPoints())\nend\n\nfor slot_name, slot in pairs(unit) do\n    if type(slot) == \"table\" and type(slot.export) == \"table\" and slot.getClass then\n        slot.slotname = slot_name\n        if slot.getClass():lower() == 'miningunit' then\n            table.insert(miningUnits, slot)\n        elseif slot.getClass():lower() == 'emitterunit' then\n            transmitter = slot\n        elseif slot.getClass():lower() == 'receiverunit' then\n            receiver = slot\n        elseif string.match(slot.getClass():lower(), \"container\") then\n            container.container = slot\n            containerInfo = {\n                type = \"container\",\n                maxVol = getMaxVolume(),\n                l = ConvertLocalToWorld(slot),\n                mass = 0,\n                vol = 0\n            }\n        end\n    end\nend\n\nif receiver then\n    local name = emitterChannel .. \"_\" .. flowerName .. \"_\" .. construct.getName()\n    name = name:gsub(\" \", \"_\")\n    receiver.setChannelList({ name })\nend\n\nfunction getContainerSelfMass()\n    local max = container.container.getSelfMass()\n    if max and max > 0 then\n        return max\n    end\n    return ContainerSelfMass(container.container.getMaxHitPoints())\nend\n\nlocal prevContainerMass = -1\n\nfunction updateContainerContents()\n\n    if not container or not container.container then\n        return\n    end\n\n    prevContainerMass = container.container.getMass()\n    containerInfo.mass = container.container.getMass() - getContainerSelfMass()\n    containerInfo.vol = container.container.getItemsVolume()\nend\n\ntransmitterData = {}\n\nfunction sendPackets()\n\n    if #transmitterData == 0 then\n        unit.stopTimer(\"emitter\")\n        return\n    end\n\n    local data = table.remove(transmitterData, 1)\n    data = serialize(data)\n    data = data:gsub(\"\\\"\", \"\\'\")\n\n    transmitter.send(emitterChannel, data)\n    if #transmitterData == 0 then\n        unit.stopTimer(\"emitter\")\n    end\nend\n\nfunction transmitData()\n    if transmitter == nil then\n        return\n    end\n    transmitterData = {}\n\n    local patchInfo = {}\n\n    patchInfo[1] = flowerName\n    patchInfo[2] = construct.getName()\n\n    local playerIds = {}\n\n    for id, miner in ipairs(miningUnitsData) do\n        local playerName = getPlayerName(miner.pid)\n        if playerName and playerName ~= \"Unknown\" then\n            playerIds[miner.pid] = playerName\n        end\n    end\n\n    patchInfo[3] = playerIds\n\n    local tempMiners = {}\n\n    local prevOreId = 0\n    for id, miner in ipairs(miningUnitsData) do\n        data = {}\n        data[1] = miner.s -- state\n        data[2] = miner.r -- Rate\n        data[3] = miner.c -- calibration\n        data[4] = miner.o -- optimal\n        data[5] = miner.e -- efficiency\n        data[6] = miner.pid -- player ID\n        data[7] = miner.et -- extraction time\n        data[8] = miner.lv -- last Volume\n        data[9] = miner.l -- last Volume\n        if prevOreId ~= miner.oid then\n            data[10] = miner.oid -- ore ID\n        end\n        prevOreId = miner.oid\n        tempMiners[#tempMiners + 1] = data\n    end\n\n    local temp = {\n        p = patchInfo,\n        m = tempMiners\n    }\n\n    local container = {}\n\n    if containerInfo then\n        container = { round(containerInfo.mass, 2), mfloor(containerInfo.maxVol), mfloor(containerInfo.vol), containerInfo.l }\n        temp.c = container\n    end\n\n    transmitterData[#transmitterData + 1] = temp\n\n    sendPackets()\nend\n\nfunction initializeMiners()\n    for index, mu in ipairs(miningUnits) do\n        mu.getActiveOre()\n    end\nend\n\ninitializeMiners()\n\nfunction getPlayerName(id)\n    local name = system.getPlayerName(id)\n    if name and string.len(name) > 0 then\n        if string.len(name) > 12 then\n            return string.sub(name, 1, 12) .. \"..\"\n        end\n        return name\n    end\n    return \"Unknown\"\nend\n\n-- Getting data from miners and sending to screen/receivers\nfunction updateMinerData()\n\n    for index, mu in ipairs(miningUnits) do\n\n        if not ores[mu.getActiveOre()] then\n            local item_data = system.getItem(mu.getActiveOre())\n            ores[mu.getActiveOre()] = { name = item_data.locDisplayName, icon = item_data.iconPath:gsub(\"resources_generated/env/\", \"\") }\n        end\n\n        local data = {\n            id = mu.getLocalId(),\n            s = mu.getState(),\n            pid = mu.getLastExtractingPlayerId(),\n            pn = getPlayerName(mu.getLastExtractingPlayerId()),\n            rt = mfloor(mu.getRemainingTime()),\n            oid = mu.getActiveOre(),\n            on = ores[mu.getActiveOre()].name,\n            oi = ores[mu.getActiveOre()].icon,\n            r = round(mu.getProductionRate(), 2),\n            c = round(mu.getCalibrationRate() * 100, 4),\n            o = mfloor(mu.getOptimalRate() * 100),\n            e = mceil(mu.getEfficiency() * 100),\n            et = mfloor(mu.getLastExtractionTime()),\n            lv = mfloor(mu.getLastExtractedVolume()),\n            l = ConvertLocalToWorld(mu, { 0, 0, 2 }),\n            time = mfloor(system.getArkTime())\n        }\n\n        miningUnitsData[index] = data\n    end\n\n    table.sort(miningUnitsData, function(k1, k2)\n        return k1.id < k2.id\n    end)\n\n    updateContainerContents()\n    prevContainerMass = 0\n\n    transmitData()\n    return true\nend\n\nfunction receivedData(data)\n\n    data = data:gsub(\"\\'\", \"\\\"\")\n    data = deserialize(data)\n\n    if not databank then\n        return\n    end\n\n    if not data then\n        return\n    end\nend\n\nfunction onStop()\n    updateMinerData()\nend\n\nunit.hideWidget()","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"2"},{"code":"---\n--- Created by Zrips.\n--- DateTime: 2022-11-10 15:11\n---\n\nmabs = math.abs\nmmin = math.min\nmmax = math.max\nmfloor = math.floor\nmceil = math.ceil\nmsqrt = math.sqrt\n\nfunction ContainerMaxVol(hp)\n    if hp > 49 and hp <= 123 then\n        vol = hub\n    elseif hp > 123 and hp <= 998 then\n        vol = (1000 + (1000 * (containerProficiency / 100)))\n    elseif hp > 998 and hp <= 7996 then\n        vol = (8000 + (8000 * (containerProficiency / 100)))\n    elseif hp > 7996 and hp <= 17315 then\n        vol = (64000 + (64000 * (containerProficiency / 100)))\n    elseif hp > 17315 and hp <= 34632 then\n        vol = (128000 + (128000 * (containerProficiency / 100)))\n    elseif hp > 34632 and hp <= 69266 then\n        vol = (256000 + (256000 * (containerProficiency / 100)))\n    elseif hp > 69266 then\n        vol = (512000 + (512000 * (containerProficiency / 100)))\n    end\n    return vol\nend\n\nfunction ContainerSelfMass(hp)\n    if hp > 49 and hp <= 123 then\n        sm = 55.8\n    elseif hp > 123 and hp <= 998 then\n        sm = 229.09\n    elseif hp > 998 and hp <= 7996 then\n        sm = 1280\n    elseif hp > 7996 and hp <= 17315 then\n        sm = 7420\n    elseif hp > 17315 and hp <= 34632 then\n        sm = 14840\n    elseif hp > 34632 and hp <= 69266 then\n        sm = 44210\n    elseif hp > 69266 then\n        sm = 88410\n    end\n    return sm\nend\n\nlocal concat = table.concat\nlocal sFormat=string.format\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = sFormat(\"[%q]=\", key)\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return sFormat(\"%q\", value)\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction deserialize(s)\n    return load(\"return \" .. s)()\nend\n\nfunction ConvertLocalToWorld(mu, offset)\n    if offset == nil then\n        offset = vec3({})\n    else\n        offset = vec3(offset)\n    end\n    local localCoord = vec3(mu.getPosition())\n    local xOffset = (localCoord.x + offset.x) * vec3(construct.getWorldRight())\n    local yOffset = (localCoord.y + offset.y) * vec3(construct.getWorldForward())\n    local zOffset = (localCoord.z + offset.z) * vec3(construct.getWorldUp())\n\n    local vect = xOffset + yOffset + zOffset + vec3(construct.getWorldPosition())\n\n    return { round(vect.x, 1), round(vect.y, 1), round(vect.z, 1) }\nend\n\nfunction round(number, decimals)\n    local power = 10 ^ decimals\n    return mfloor(mceil(number * power)) / power\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"3"}],"methods":[],"events":[]}
