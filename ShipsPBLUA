{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"receivedData(message)","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"onReceived(channel,message)","slotKey":"0"},"key":"0"},{"code":"---\n--- Created by Zrips.\n--- DateTime: 2022-10-13 18:36\n---\n\nemitterChannel = \"\" --export: Channel name. Keep \" at front and end\n\ncontainerProficiency = 0 --export: This is the Container Proficiency talent level. Defaults to 1\ncontainerOptimization = 0 --export: This is the Container Optimization talent level. Defaults to 1\n\nminimalCalibration = 0 --export: Percentage for minimal miner calibrations. Defaults to 50\n\nallowEdit = true --export: When enabled will allot tile manual editing\nallowDelete = true --export: When enabled will allot tile removal\nacceptNewRecords = true --export: When enabled new patches will be accepted into record\n\nfootNoteX = 0 --export: Footnote X % coordinate. Defaults to 5\nfootNoteY = 0 --export: Footnote Y % coordinate. Defaults to 15\n\nhubSize = 0 --export: Hub size if in use on mining platforms. Defaults to 153600\n\nversion = \"v1.5.0\"\n\ndataSyncChannel = (emitterChannel .. \"_DataSync\"):gsub(\" \", \"_\")\ndataSyncPersonalChannel = (emitterChannel .. \"_\" .. construct.getId()):gsub(\" \", \"_\")\n\nlocal enterPatchDistance = 20\nlocal leavePatchDistance = enterPatchDistance + 5\nlocal patchGroupDistance = 150\n\nscreens = {}\nminingUnits = {}\nminingUnitsData = {}\ncontainer = {}\n\nores = {}\ndatabank = nil\n\nreceiver = nil\ntransmitter = nil\n\nswitch = nil\n\nreceiverMessage = nil\n\nplayersCache = {}\nplayers = {}\n\nclosestFlower = nil\nclosestPatches = {}\n\nenteredPatches = {}\n\npatchUpdates = {}\ncurrentClosests = \"\"\npreviousClosests = \"\"\nlocal minerRequestDataNames = {}\n\nminingPost = false\nmainPost = false\n\nsettings = {}\n\nlocal atlas = require(\"atlas\")\nlocal coreAtlas = atlas[0]\n\nfunction round(number, decimals)\n    local power = 10 ^ decimals\n    return mfloor(mceil(number * power)) / power\nend\n\nfunction getMaxVolume()\n    local max = container.container.getMaxVolume()\n    if max and max > 0 then\n        return max\n    end\n    return ContainerMaxVol(container.container.getMaxHitPoints())\nend\n\nfor slot_name, slot in pairs(unit) do\n    if type(slot) == \"table\" and type(slot.export) == \"table\" and slot.getClass then\n        slot.slotname = slot_name\n        if slot.getClass():lower() == 'screenunit' then\n            table.insert(screens, { screen = slot })\n            slot.setScriptInput(\"\")\n            slot.setRenderScript(getScreenScript())\n        elseif slot.getClass():lower() == 'miningunit' then\n            table.insert(miningUnits, slot)\n        elseif slot.getClass():lower() == 'manualswitchunit' then\n            switch = slot\n        elseif slot.getClass():lower() == 'emitterunit' then\n            transmitter = slot\n        elseif slot.getClass():lower() == 'receiverunit' then\n            receiver = slot\n        elseif slot.getClass():lower() == 'databankunit' then\n            databank = slot\n        elseif string.match(slot.getClass():lower(), \"container\") then\n            container.container = slot\n\n            containerInfo = {}\n            containerInfo.type = \"container\"\n            containerInfo.maxVol = getMaxVolume()\n            containerInfo.l = ConvertLocalToWorld(slot)\n        end\n    end\nend\n\nif #miningUnits > 0 or container.container then\n    miningPost = true\nelse\n    mainPost = true\nend\n\nif databank then\n    settings = loadFromDataBank(\"Settings\")\n\n    if string.len(emitterChannel) == 0 then\n        if settings.ec then\n            emitterChannel = settings.ec\n        else\n            system.print(\"UNDEFINED RECEIVER CHANNEL!\")\n            unit.exit()\n            return\n        end\n    else\n        settings.ec = emitterChannel\n    end\n\n    if containerProficiency < 1 then\n        if settings.cp then\n            containerProficiency = settings.cp\n        else\n            system.print(\"UNDEFINED CONTAINER PROFICIENCY! Defaulting to 1\")\n            containerProficiency = 1\n        end\n    else\n        settings.cp = containerProficiency\n    end\n\n    if containerOptimization < 1 then\n        if settings.co then\n            containerOptimization = settings.co\n        else\n            system.print(\"UNDEFINED CONTAINER OPTIMIZATION! Defaulting to 1\")\n            containerOptimization = 1\n        end\n    else\n        settings.co = containerOptimization\n    end\n\n    if minimalCalibration < 1 then\n        if settings.mc then\n            minimalCalibration = settings.mc\n        else\n            system.print(\"UNDEFINED MINIMAL CALIBRATION! Defaulting to 50\")\n            minimalCalibration = 50\n        end\n    else\n        settings.mc = minimalCalibration\n    end\n\n    if footNoteX < 1 then\n        if settings.fnx then\n            footNoteX = settings.fnx\n        else\n            footNoteX = 5\n        end\n    else\n        settings.fnx = footNoteX\n    end\n\n    if footNoteY < 1 then\n        if settings.fny then\n            footNoteY = settings.fny\n        else\n            footNoteY = 15\n        end\n    else\n        settings.fny = footNoteY\n    end\n\n    if hubSize < 1 then\n        if settings.hs then\n            hubSize = settings.hs\n        else\n            hubSize = 153600\n        end\n    else\n        settings.hs = hubSize\n    end\n\n\nend\n\nfunction checkMode()\n    if not databank then\n        return\n    end\n\n    local prevInfo = loadFromDataBank(\"launchInfo\")\n    if not prevInfo then\n        return\n    end\n\n    if not prevInfo.start or not prevInfo.stop then\n        return\n    end\n    local dif = prevInfo.stop - prevInfo.start\n\n    saveToDataBank(\"launchInfo\", prevInfo)\nend\n\ncheckMode()\n\nplayersCache = {}\nfor id, name in pairs(loadFromDataBank(\"Players\")) do\n    if name ~= \"Unknown\" then\n        playersCache[id] = name\n    end\nend\n\nlocal previousOre = 0\n\nlocal showed = false\nlocal showed2 = false\n\nfunction expandPatchData(flowerName, patch)\n\n    local expandedPatch = {}\n\n    expandedPatch.time = patch[1]\n\n    local center = {}\n\n    expandedPatch.miners = {}\n\n    local previousPID = 0\n    local previousOreID = 0\n\n    local miners = patch[2]\n\n    local originPoint = {}\n\n    for _, miner in ipairs(miners) do\n\n        local expandedMiner = {}\n\n        expandedMiner.s = miner[1]\n        expandedMiner.r = miner[2]\n        expandedMiner.c = miner[3]\n\n        local mloc = miner[4]\n\n        if #originPoint == 0 then\n            originPoint = { mloc[1], mloc[2], mloc[3] }\n            mloc = expandLocation(mloc)\n        else\n            if mabs(mloc[1]) < 150 and mabs(mloc[2]) < 150 and mabs(mloc[3]) < 150 then\n                mloc = reOffsetLocation(originPoint, mloc)\n            else\n                mloc = expandLocation(mloc)\n            end\n        end\n\n        expandedMiner.l = mloc\n\n        local efop = miner[5]\n        local efficiency = 115\n        local optimal = 100\n\n        if #efop == 2 then\n            optimal = efop[2]\n        end\n\n        if #efop > 0 then\n            efficiency = efop[1]\n        end\n\n        expandedMiner.e = efficiency\n        expandedMiner.o = optimal\n\n        local eep = miner[6]\n\n        local extractionTime = 0\n        local extractionVolume = 0\n\n        if #eep > 0 then\n            extractionTime = eep[1]\n        end\n\n        if #eep > 1 then\n            extractionVolume = eep[2]\n        end\n\n        if #eep > 2 then\n            previousPID = eep[3]\n        end\n\n        expandedMiner.pid = previousPID\n        expandedMiner.et = extractionTime\n        expandedMiner.lv = extractionVolume\n\n        if miner[7] then\n            previousOreID = miner[7]\n        end\n        expandedMiner.oid = previousOreID\n\n        expandedPatch.miners[#expandedPatch.miners + 1] = expandedMiner\n    end\n\n    if patch[3] then\n        local cont = patch[3]\n        if cont then\n            local cloc = cont[1]\n            if #originPoint == 0 then\n                cloc = expandLocation(cloc)\n            else\n                if mabs(cloc[1]) < 150 and mabs(cloc[2]) < 150 and mabs(cloc[3]) < 150 then\n                    cloc = reOffsetLocation(originPoint, cloc)\n                else\n                    cloc = expandLocation(cloc)\n                end\n            end\n\n            local container = {\n                l = cloc,\n                maxVol = cont[2],\n                vol = cont[3] or 0,\n                mass = cont[4] or 0,\n            }\n\n            if container.maxVol == 0 then\n                container.maxVol = hubSize\n            end\n\n            expandedPatch.c = container\n        end\n    end\n    return expandedPatch\nend\n\nfunction isFractional(value)\n    return value - mfloor(value) ~= 0\nend\n\nfunction getPatchCenterByPatch(patch)\n\n    if not patch then\n        return {}\n    end\n\n    if patch.center then\n        return patch.center\n    end\n\n    local centerLoc = {}\n    local val = 1000000000000\n    local max = { x = -val, y = -val, z = -val }\n    local min = { x = val, y = val, z = val }\n\n    for index, miner in ipairs(patch.miners) do\n        if miner.l[1] > max.x then\n            max.x = miner.l[1]\n        end\n        if miner.l[2] > max.y then\n            max.y = miner.l[2]\n        end\n        if miner.l[3] > max.z then\n            max.z = miner.l[3]\n        end\n        if miner.l[1] < min.x then\n            min.x = miner.l[1]\n        end\n        if miner.l[2] < min.y then\n            min.y = miner.l[2]\n        end\n        if miner.l[3] < min.z then\n            min.z = miner.l[3]\n        end\n    end\n    centerLoc = { (max.x + min.x) / 2, (max.y + min.y) / 2, (max.z + min.z) / 2 }\n\n    patch.center = centerLoc\n\n    return centerLoc\nend\n\nfunction getPatchCenter(flowerName, patchName)\n    local loadedPatch = dataBankPatches[flowerName .. \"_\" .. patchName]\n    return getPatchCenterByPatch(loadedPatch)\nend\n\nfunction compactLocation(location)\n    return { location[1], location[2], location[3] }\n    --return { mfloor(location[1] * 10), mfloor(location[2] * 10), mfloor(location[3] * 10) }\nend\n\nfunction expandLocation(location)\n\n    return { location[1], location[2], location[3] }\n\n    --return { location[1] / 10, location[2] / 10, location[3] / 10 }\nend\n\nfunction offsetLocation(origin, location)\n    return compactLocation({ round(origin[1] - location[1], 2), round(origin[2] - location[2], 2), round(origin[3] - location[3], 2) })\nend\n\nfunction reOffsetLocation(origin, location)\n    return expandLocation({ origin[1] - location[1], origin[2] - location[2], origin[3] - location[3] })\nend\n\nfunction compactPatchData(patch)\n\n    local previousPID = 0\n    local previousOreID = 0\n\n    local compactedPatch = {}\n\n    compactedPatch[1] = patch.time\n    compactedPatch[2] = {}\n\n    local originPoint = {}\n\n    for _, miner in ipairs(patch.miners) do\n\n        local efficiency = miner.e\n        local optimal = miner.o\n\n        if optimal == 100 then\n            optimal = nil\n        end\n\n        if efficiency == 115 and optimal == nil then\n            efficiency = nil\n        end\n\n        local pid = miner.pid\n\n        if pid == previousPID then\n            pid = nil\n        else\n            previousPID = pid\n        end\n\n        local lastVolume = miner.lv\n\n        if pid == nil and lastVolume == 0 then\n            lastVolume = nil\n        end\n\n        local oreID = miner.oid\n\n        if oreID == previousOreID then\n            oreID = nil\n        else\n            previousOreID = oreID\n        end\n\n        local rate = miner.r\n        local calibration = miner.c\n\n        if not isFractional(rate) then\n            rate = mfloor(rate)\n        end\n\n        if not isFractional(calibration) then\n            calibration = mfloor(calibration)\n        else\n            calibration = round(calibration, 1)\n        end\n\n        local mloc = miner.l\n\n        if #originPoint == 0 then\n            originPoint = { mloc[1], mloc[2], mloc[3] }\n            mloc = compactLocation(mloc)\n        else\n            mloc = offsetLocation(originPoint, mloc)\n        end\n\n        local compactMiner = {\n            miner.s,\n            rate,\n            calibration,\n            mloc,\n            { efficiency, optimal },\n            { miner.et, lastVolume, pid },\n            oreID\n        }\n        compactedPatch[2][#compactedPatch[2] + 1] = compactMiner\n    end\n\n    if patch.c then\n\n        local mass = mfloor(patch.c.mass)\n        if mass == 0 then\n            mass = nil\n        end\n\n        local vol = patch.c.vol\n        if vol == nil and mass == nil then\n            vol = nil\n        end\n\n        if vol ~= nil then\n            vol = mfloor(vol)\n        end\n\n        local mloc = patch.c.l\n        if #originPoint ~= 0 then\n            mloc = offsetLocation(originPoint, mloc)\n        end\n\n        local container = {\n            mloc,\n            patch.c.maxVol,\n            vol,\n            mass\n        }\n\n        if container[2] == hubSize then\n            container.maxVol = 0\n        end\n\n        compactedPatch[3] = container\n    end\n\n    return compactedPatch\nend\n\nlocal campacted = false\n\nfunction updateDataBankCache()\n    dataBankFlowers = loadFromDataBank(\"_Flowers_\")\n    dataBankPatches = {}\n\n    for name, f in pairs(dataBankFlowers) do\n        for _, patchName in pairs(f.p) do\n            local loadedPatch = loadFromDataBank(name .. \"_\" .. patchName)\n            if loadedPatch then\n                if not loadedPatch.time then\n\n\n                    loadedPatch = expandPatchData(name, loadedPatch)\n                end\n                dataBankPatches[name .. \"_\" .. patchName] = loadedPatch\n            end\n        end\n    end\nend\n\nupdateDataBankCache()\n\nif receiver and miningPost then\n    local name = emitterChannel .. \"_\" .. flowerName .. \"_\" .. construct.getName()\n    name = name:gsub(\" \", \"_\")\n    receiver.setChannelList({ name })\nend\n\nif receiver and mainPost then\n    receiver.setChannelList({ dataSyncChannel, emitterChannel, dataSyncPersonalChannel })\nend\n\nPBstartTime = system.getArkTime()\n\nfunction recordStart()\n    local prevInfo = loadFromDataBank(\"launchInfo\")\n    if not prevInfo then\n        prevInfo = {}\n    end\n    prevInfo.start = PBstartTime\n    saveToDataBank(\"launchInfo\", prevInfo)\nend\n\nif miningPost then\n    recordStart()\nend\n\nfunction recordStop()\n    local prevInfo = loadFromDataBank(\"launchInfo\")\n    if not prevInfo then\n        prevInfo = {}\n    end\n    prevInfo.stop = system.getArkTime()\n    saveToDataBank(\"launchInfo\", prevInfo)\nend\n\nfunction getExisting(id)\n    for i, item in ipairs(containerInfo.ores) do\n        if item.id == id then\n            return i, item\n        end\n    end\n    return -1, nil\nend\n\nfunction getContainerSelfMass()\n    local max = container.container.getSelfMass()\n    if max and max > 0 then\n        return max\n    end\n    return ContainerSelfMass(container.container.getMaxHitPoints())\nend\n\nfunction sendContainerInformation()\n    local data = serialize(containerInfo)\n    for id, screenObject in ipairs(screens) do\n        screenObject.screen.setScriptInput(data)\n    end\nend\n\nlocal prevContainerMass = 0\n\nfunction updateContainerContents()\n\n    if not container or not container.container then\n        return\n    end\n\n    prevContainerMass = container.container.getMass()\n    containerInfo.mass = container.container.getMass() - getContainerSelfMass()\n    containerInfo.vol = container.container.getItemsVolume()\nend\n\nfunction getPlayerName(id)\n    local name = system.getPlayerName(id)\n    if name and string.len(name) > 0 then\n        return name\n    end\n    name = playersCache[id]\n    if name and string.len(name) > 0 then\n        return name\n    end\n    return \"Unknown\"\nend\n\nfunction sendPatchInformationToScreen()\n\n    if #miningUnits == 0 then\n        return\n    end\n\n    local information = {}\n\n    information.type = \"miners\"\n    information.t = system.getArkTime()\n\n    local miners = {}\n    local ores = {}\n\n    local time = 0\n    for index, miner in ipairs(miningUnitsData) do\n        local item_data = system.getItem(miner.oid)\n\n        if not ores[miner.oid] then\n            ores[miner.oid] = {\n                item_data.locDisplayName,\n                item_data.iconPath:gsub(\"resources_generated/env/\", \"\")\n            }\n        end\n\n        miner.pn = getPlayerName(miner.pid)\n\n        miners[#miners + 1] = {\n            miner.s, -- 1 State\n            miner.r, -- 2 Rate\n            miner.c, -- 3 Calibration\n            miner.o, -- 4 Optimal\n            miner.e, -- 5 efficientcy\n            miner.pid, -- 6 player ID\n            miner.et, -- 7 extraction time\n            miner.lv, -- 8 last Volume\n            miner.oid, -- 9 ore ID\n            miner.pn -- 10 Player name\n        }\n    end\n\n    information.miners = miners\n    information.ores = ores\n\n    for id, miner in ipairs(information.miners) do\n        table.removekey(miner, \"id\")\n        --table.removekey(miner, \"pid\")\n        --table.removekey(miner, \"oid\")\n    end\n\n    local data = serialize(information)\n\n    for id, screenObject in ipairs(screens) do\n        screenObject.screen.setScriptInput(data)\n    end\nend\n\nfunction getLowestMinerInfo(patch)\n    local lowestMiner = 100\n    local lowestMinerTime = 99999999\n    local lastCalib = 99999999\n    if patch then\n        for index, miner in ipairs(patch.miners) do\n            local estimateCalib = estimateCalibration(miner.c, miner.et, patch.time, true)\n            local nextCalTime = timeUntilReCalibration(estimateCalib, miner.et, patch.time, mmin(miner.o, minimalCalibration))\n            if nextCalTime < lowestMinerTime then\n                lowestMiner = estimateCalib\n                lowestMinerTime = nextCalTime\n                lastCalib = system.getArkTime() - patch.time + miner.et\n            end\n        end\n    end\n\n    if lowestMinerTime < 0 then\n        lowestMinerTime = 0\n    end\n\n    return round(lastCalib, 0), round(lowestMiner, 2), round(lowestMinerTime, 0)\nend\n\nfunction getFlowerCenter(flowerName)\n\n    local flowerName = flowerName:gsub(\" \", \"_\")\n    local flower = dataBankFlowers[flowerName]\n\n    if flower.center then\n        return flower.center\n    end\n\n    local centerLoc = {}\n    local val = 1000000000000\n    local max = { x = -val, y = -val, z = -val }\n    local min = { x = val, y = val, z = val }\n\n    for _, patchName in pairs(flower.p) do\n        local patch = {}\n        patch.name = patchName\n\n        local loadedPatch = dataBankPatches[flowerName .. \"_\" .. patchName]\n\n        if loadedPatch then\n            for index, miner in ipairs(loadedPatch.miners) do\n                if miner.l[1] > max.x then\n                    max.x = miner.l[1]\n                end\n                if miner.l[2] > max.y then\n                    max.y = miner.l[2]\n                end\n                if miner.l[3] > max.z then\n                    max.z = miner.l[3]\n                end\n                if miner.l[1] < min.x then\n                    min.x = miner.l[1]\n                end\n                if miner.l[2] < min.y then\n                    min.y = miner.l[2]\n                end\n                if miner.l[3] < min.z then\n                    min.z = miner.l[3]\n                end\n            end\n        end\n    end\n\n    centerLoc = { (max.x + min.x) / 2, (max.y + min.y) / 2, (max.z + min.z) / 2 }\n\n    flower.center = centerLoc\n\n    return centerLoc\nend\n\nfunction getFlowerPlanet(flowerName)\n\n    local flowerName = flowerName:gsub(\" \", \"_\")\n    local flower = dataBankFlowers[flowerName]\n\n    if not flower then\n        return\n    end\n\n    if flower.planet then\n        return flower.planet\n    end\n\n    local center = getFlowerCenter(flowerName)\n    local body = getClosestBody(center)\n\n    if body then\n        flower.planet = body.name[1]\n    end\n\n    return flower.planet\nend\n\nfunction getCenter(locations)\n\n    local val = 1000000000000\n    local max = { x = -val, y = -val, z = -val }\n    local min = { x = val, y = val, z = val }\n\n    for index, loc in ipairs(locations) do\n        if loc[1] > max.x then\n            max.x = loc[1]\n        end\n        if loc[2] > max.y then\n            max.y = loc[2]\n        end\n        if loc[3] > max.z then\n            max.z = loc[3]\n        end\n        if loc[1] < min.x then\n            min.x = loc[1]\n        end\n        if loc[2] < min.y then\n            min.y = loc[2]\n        end\n        if loc[3] < min.z then\n            min.z = loc[3]\n        end\n    end\n\n    return { (max.x + min.x) / 2, (max.y + min.y) / 2, (max.z + min.z) / 2 }\nend\n\nfunction getClosestBody(coordinates)\n    local distance = 9999999999\n    local body = nil\n    for _, params in pairs(coreAtlas) do\n        local temp = getDistance(params.center, coordinates)\n        if (not body or temp < distance) and params.name ~= \"Space\" then\n            -- Only care about planets and moons\n            body = params\n            distance = temp\n            if distance < 1000 * 200 then\n                -- if closer than 1 SU lets stop cycling\n                return body\n            end\n        end\n    end\n    return body\nend\n\nfunction sendFlowersInformation(screen)\n\n    local flowers = {}\n\n    local playerLoc = player.getWorldPosition()\n\n    local previousPlanet = nil\n\n    local tkeys = {}\n    for name, f in pairs(dataBankFlowers) do\n        table.insert(tkeys, name)\n    end\n    table.sort(tkeys, function(k1, k2)\n        if getFlowerPlanet(k1) ~= getFlowerPlanet(k2) then\n            return getFlowerPlanet(k1) < getFlowerPlanet(k2)\n        end\n        return k1 < k2\n    end)\n    local temp = {}\n    for _, k in ipairs(tkeys) do\n        temp[k] = dataBankFlowers[k]\n    end\n\n    for _, k in ipairs(tkeys) do\n\n        local name = k\n        local f = dataBankFlowers[name]\n\n        local flower = {}\n\n        local currentPlanet = getFlowerPlanet(name)\n\n        flower[1] = { name, currentPlanet }\n\n        if previousPlanet == currentPlanet then\n            flower[1][2] = nil\n        else\n            previousPlanet = currentPlanet\n        end\n\n        local miners = 0\n        local patches = {}\n        local lowestMinerTime = 99999999\n        flower[4] = {}\n\n        local highestContainer = 0\n        local totalMass = 0\n        local totalVol = 0\n\n        for _, patchName in pairs(f.p) do\n\n            local loadedPatch = dataBankPatches[name .. \"_\" .. patchName]\n\n            if loadedPatch then\n                for index, miner in ipairs(loadedPatch.miners) do\n                    miners = miners + 1\n                end\n\n                local fct, c, ct = getLowestMinerInfo(loadedPatch)\n\n                if ct < lowestMinerTime then\n                    lowestMinerTime = ct\n                    flower[4][1] = c\n                    flower[4][2] = mfloor(ct)\n                    flower[4][3] = mfloor(fct)\n                end\n\n                local mass, vol = estimateContainerContents(loadedPatch.c, loadedPatch)\n\n                if loadedPatch.c then\n                    local v = mmin(vol / loadedPatch.c.maxVol, 1)\n                    if highestContainer < v then\n                        highestContainer = v\n                    end\n                end\n\n                totalMass = totalMass + mass\n                totalVol = totalVol + vol\n            end\n        end\n\n        local center = getFlowerCenter(name)\n        flower[2] = mfloor(getDistance(playerLoc, center))\n        flower[3] = miners\n\n        flower[5] = {\n            round(highestContainer, 2),\n            mfloor(totalMass / 1000),\n            mfloor(totalVol / 1000)\n        }\n\n        flowers[#flowers + 1] = flower\n    end\n\n    local temp = {}\n    temp.type = \"flowers\"\n    temp.f = flowers\n    local serialized = serialize(temp)\n\n    --system.print(\"Length: \" .. string.len(serialized))\n    --system.print(serialized)\n\n    if screen then\n        screen.setScriptInput(serialized)\n    else\n        for id, screenObject in ipairs(screens) do\n            screenObject.screen.setScriptInput(serialized)\n        end\n    end\n\nend\n\nlocal lastFlowerCheck = 0\nlocal lastPatchCheck = 0\nlocal lastEnterCheck = 0\n\nfunction getClosestFlower()\n\n    if system.getArkTime() - lastFlowerCheck < 3 then\n        return\n    end\n\n    lastFlowerCheck = system.getArkTime()\n    local playerLoc = player.getWorldPosition()\n\n    local distance = 100000000000000000\n\n    for flowerName, flower in pairs(dataBankFlowers) do\n        local center = getFlowerCenter(flowerName)\n        local dist = getDistance(playerLoc, center)\n        if dist < distance then\n            closestFlower = flowerName\n            distance = dist\n        end\n    end\nend\n\nlocal lastAutoSync = 0\n\nlocal function enterLeveDataRequest(patchName)\n    if not transmitter then\n        return\n    end\n\n    lastAutoSync = system.getArkTime()\n\n    minerRequestDataNames = { { name = closestFlower .. \"_\" .. patchName, cycle = 0 } }\n    requestMinerData()\nend\n\nfunction enteredPatch(patchName)\n    enterLeveDataRequest(patchName)\nend\n\nfunction leftPatch(patchName)\n    enterLeveDataRequest(patchName)\nend\n\n-- 1 - sync on enter/leave\n-- 2 - sync on enter\n-- 3 - sync on leave\n-- 4 - off\n\nfunction checkEnteredPatches()\n\n    if system.getArkTime() - lastAutoSync > 10 then\n        if #closestPatches > 0 and closestPatches[1].distance <= enterPatchDistance then\n            lastEnterCheck = system.getArkTime()\n            enteredPatch(closestPatches[1].name)\n        end\n    end\n\n    if system.getArkTime() - lastEnterCheck < 0.3 then\n        return\n    end\n\n    lastEnterCheck = system.getArkTime()\n\n    if not linkedMaster then\n        return\n    end\n\n    local playerLoc = player.getWorldPosition()\n\n    for id, patch in pairs(closestPatches) do\n        if id > 3 then\n            break\n        end\n\n        local center = getPatchCenter(closestFlower, patch.name)\n\n        patchData = getPatchInformationFromDatabank(closestFlower, patch.name)\n\n        if patchData and patchData.c and patchData.c.l then\n            center = patchData.c.l\n        end\n\n        local dist = getDistance(playerLoc, center)\n\n        if dist <= enterPatchDistance then\n            if not table_has_value(enteredPatches, patch.name) then\n                enteredPatch(patch.name)\n                enteredPatches[#enteredPatches + 1] = patch.name\n                return\n            end\n        elseif dist >= leavePatchDistance then\n            local pos = table_get_position(enteredPatches, patch.name)\n            if pos > 0 then\n                leftPatch(patch.name)\n                enteredPatches[pos] = nil\n                return\n            end\n        end\n    end\nend\n\nlocal lastCheckLocation = nil\n\nfunction getClosestPatches()\n\n    if system.getArkTime() - lastPatchCheck >= 15 then\n        recheckForClosestPatches()\n        return\n    end\n\n    if lastCheckLocation == nil then\n        recheckForClosestPatches()\n        return\n    end\n\n    if getDistance(player.getWorldPosition(), lastCheckLocation) > 100 then\n        recheckForClosestPatches()\n        lastCheckLocation = player.getWorldPosition()\n        return\n    end\n\nend\n\nfunction recheckForClosestPatches()\n    if not closestFlower then\n        return\n    end\n\n    lastPatchCheck = system.getArkTime()\n    local playerLoc = player.getWorldPosition()\n\n    local distance = 100000000000000000\n\n    local flower = dataBankFlowers[closestFlower]\n\n    closestPatches = {}\n\n    if flower then\n        for _, patchName in pairs(flower.p) do\n            local center = getPatchCenter(closestFlower, patchName)\n            local dist = getDistance(playerLoc, center)\n            closestPatches[#closestPatches + 1] = {\n                name = patchName,\n                distance = dist\n            }\n        end\n    end\n\n    if closestPatches and #closestPatches > 1 then\n        table.sort(closestPatches, function(k1, k2)\n            return k1.distance < k2.distance\n        end)\n    end\n\n    currentClosests = \"\"\n    for i = 1, 3 do\n        local temp = closestPatches[i]\n        if temp then\n            currentClosests = currentClosests .. temp.name\n        end\n    end\n\n\nend\n\nfunction sendFlowerInformation(screen, flowerName)\n\n    local flowers = {}\n\n    local flower = dataBankFlowers[flowerName]\n\n    if not flower then\n        return\n    end\n\n    local patches = {}\n\n    local playerLoc = player.getWorldPosition()\n\n    local totalMass = 0\n    local totalVol = 0\n\n    for _, patchName in pairs(flower.p) do\n        local patch = {}\n        patch[1] = patchName\n\n        local loadedPatch = dataBankPatches[flowerName .. \"_\" .. patchName]\n\n        if loadedPatch then\n            patch[2] = #loadedPatch.miners\n        end\n\n        if loadedPatch then\n            patch[3] = loadedPatch.time\n        end\n\n        patch[4] = {}\n\n        patch[4][3], patch[4][1], patch[4][2] = getLowestMinerInfo(loadedPatch)\n\n        --patch.l.fct, patch.l.c, patch.l.ct = getLowestMinerInfo(loadedPatch)\n\n        patch[5] = getDistance(playerLoc, getPatchCenter(flowerName, patchName))\n\n        if loadedPatch.c then\n            local mass, vol = estimateContainerContents(loadedPatch.c, loadedPatch)\n\n            patch[6] = mmin(vol / loadedPatch.c.maxVol, 1)\n\n            totalMass = totalMass + mass\n            totalVol = totalVol + vol\n        end\n\n        patches[#patches + 1] = patch\n    end\n\n    table.sort(patches, function(k1, k2)\n        return k1[1] < k2[1]\n    end)\n\n    local Tflower = {}\n\n    Tflower.patches = patches\n    Tflower.name = flowerName\n\n    if totalMass > 0 then\n        totalMass = round(totalMass / 1000, 2)\n        totalVol = round(totalVol / 1000, 2)\n        Tflower.c = { totalMass, totalVol }\n    end\n\n    local temp = {}\n    temp.type = \"flower\"\n    temp.flower = Tflower\n    temp.t = mfloor(system.getArkTime())\n\n    local serialized = serialize(temp)\n\n    screen.setScriptInput(serialized)\nend\n\nlocal lastScreenRequest = {}\nfunction receivedData(data)\n\n    data = data:gsub(\"\\'\", \"\\\"\")\n    data = deserialize(data)\n\n    if not databank then\n        return\n    end\n\n    if not data then\n        return\n    end\n\n    if data.brakeLink then\n        brakeLink()\n    elseif data.dsync then\n        if data.p then\n            dataSyncReceived(data)\n        else\n            dataReceiveHandShake(data)\n        end\n\n    elseif data.sync then\n        if data.alive then\n            receiveAlive(data)\n        else\n            onDataSyncHandShake(data)\n        end\n        -- Saving patch data transmitted from mining post\n    elseif data.p and data.m then\n\n        dataBankFlowers = loadFromDataBank(\"_Flowers_\")\n\n        local patchInfo = data.p\n        local minerInfo = data.m\n        local playersInfo = patchInfo[3]\n\n        local flowerName = patchInfo[1]:gsub(\" \", \"_\")\n        local patchName = patchInfo[2]:gsub(\" \", \"_\")\n\n        local keyName = flowerName .. \"_\" .. patchName\n\n        local flower = dataBankFlowers[flowerName]\n\n        if not flower then\n            flower = {}\n            flower.p = {}\n        end\n\n        flower.time = mfloor(system.getArkTime())\n\n        local contains = table_contains(flower.p, patchName)\n\n        if not contains then\n\n            if not acceptNewRecords then\n                system.print(\"Skipped new patch record for \" .. flowerName .. \" flower with \" .. patchName .. \" patch name\")\n                return\n            end\n\n            flower.p[#flower.p + 1] = patchName\n        end\n\n        dataBankFlowers[flowerName] = flower\n\n        saveToDataBank(\"_Flowers_\", dataBankFlowers)\n\n        local patch = dataBankPatches[keyName]\n\n        if not patch then\n            patch = {}\n        end\n\n        if data.c then\n\n            local container = {\n                mass = data.c[1],\n                maxVol = data.c[2],\n                vol = data.c[3],\n                l = data.c[4]\n            }\n\n            if container.maxVol == 192000 then\n                container.maxVol = hubSize\n            end\n\n            patch.c = container\n        else\n            if patch.c and patch.miners then\n                patch.c.mass, patch.c.vol = estimateContainerContents(patch.c, patch)\n            end\n        end\n\n        patch.miners = {}\n\n        local previousOre = 0\n        for id, data in ipairs(minerInfo) do\n\n            miner = {}\n\n            miner.s = data[1]  -- state\n            miner.r = data[2]  -- Rate\n            miner.c = data[3]  -- calibration\n            miner.o = data[4]  -- optimal\n            miner.e = data[5]  -- efficientcy\n            miner.pid = data[6] -- player ID\n            miner.et = data[7]   -- extraction time\n            miner.lv = data[8]  -- last Volume\n            miner.l = data[9]  -- last Volume\n\n            if data[10] then\n                previousOre = data[10]\n            end\n            miner.oid = previousOre  -- ore ID\n\n            patch.miners[#patch.miners + 1] = miner\n        end\n\n        patch.time = mfloor(system.getArkTime())\n\n        saveToDataBank(keyName, compactPatchData(patch))\n        dataBankPatches[keyName] = patch\n\n        if playersInfo then\n            for id, player in pairs(playersInfo) do\n                if player ~= \"Unknown\" then\n                    playersCache[id] = player\n                end\n            end\n            saveToDataBank(\"Players\", serialize(playersCache))\n        end\n\n        currentClosests = \"\"\n\n        for id, screenObject in ipairs(screens) do\n            if lastScreenRequest.type then\n                processScreenRequest(screenObject.screen, lastScreenRequest)\n            else\n                sendFlowersInformation()\n            end\n        end\n        updateAR()\n    end\nend\n\nfunction receivedScreenEditData(screen, data)\n\n    if not allowEdit then\n        return\n    end\n\n    if not databank then\n        return\n    end\n\n    if not data then\n        return\n    end\n\n    if not data.p and data.m then\n        return\n    end\n\n    dataBankFlowers = loadFromDataBank(\"_Flowers_\")\n\n    local patchInfo = data.p\n    local minerInfo = data.m\n\n    local flowerName = patchInfo[1]:gsub(\" \", \"_\")\n    local patchName = patchInfo[2]:gsub(\" \", \"_\")\n\n    local keyName = flowerName .. \"_\" .. patchName\n\n    local flower = dataBankFlowers[flowerName]\n\n    if not flower then\n        flower = {}\n        flower.p = {}\n    end\n\n    flower.time = mfloor(system.getArkTime())\n\n    local contains = table_contains(flower.p, patchName)\n\n    if not contains then\n        flower.p[#flower.p + 1] = patchName\n    end\n\n    dataBankFlowers[flowerName] = flower\n\n    saveToDataBank(\"_Flowers_\", dataBankFlowers)\n\n    local patch = getPatchInformationFromDatabank(flowerName, patchName)\n\n    if data.c then\n        container = patch.c\n        container.mass = data.c[1]\n        container.vol = data.c[2]\n        patch.c = container\n    else\n        if patch.c and patch.miners then\n            patch.c.mass, patch.c.vol = estimateContainerContents(patch.c, patch)\n        end\n    end\n\n    patch.time = mfloor(system.getArkTime())\n\n    for id, data in ipairs(minerInfo) do\n\n        local miner = patch.miners[id]\n\n        if miner and data[6] == -1 then\n\n            miner.r = data[2]  -- Rate\n            miner.c = data[3]  -- calibration\n            miner.pid = player.getId() -- player ID\n            miner.et = 1   -- extraction time\n            miner.lv = -1  -- last Volume\n\n            patch.miners[id] = miner\n        end\n    end\n\n    saveToDataBank(keyName, compactPatchData(patch))\n    dataBankPatches[keyName] = patch\n\n    currentClosests = \"\"\n\n    playersCache[player.getId()] = player.getName()\n    saveToDataBank(\"Players\", serialize(playersCache))\n\n    if lastScreenRequest.type then\n        processScreenRequest(screen, lastScreenRequest)\n    end\nend\n\nscreenOutput = \"\"\n\nfunction getPatchInformationFromDatabank(flowerName, patchName)\n    return dataBankPatches[flowerName .. \"_\" .. patchName] or {}\nend\n\nfunction sendClosestInfoToScreens(screen)\n    if closestPatches and closestPatches[1] then\n        local closestFlowerData = {\n            type = \"closest\",\n            flower = closestFlower,\n            patch = closestPatches[1].name,\n            distance = closestPatches[1].distance,\n        }\n\n        closestFlowerData = serialize(closestFlowerData)\n        if screen then\n            screen.setScriptInput(closestFlowerData)\n        else\n            for id, screenObject in ipairs(screens) do\n                screenObject.screen.setScriptInput(closestFlowerData)\n            end\n        end\n    end\nend\n\nfunction deleteRecord(screen, data)\n    if not allowDelete then\n        return\n    end\n\n    if data.miner then\n    elseif data.patch then\n        local dataBankFlowers = loadFromDataBank(\"_Flowers_\")\n        if dataBankFlowers then\n            local flower = dataBankFlowers[data.fn]\n            if flower then\n                table.removeFirst(flower.p, data.patch)\n                if databank then\n                    databank.clearValue(data.fn .. \"_\" .. data.patch)\n                end\n\n                if #flower.p == 0 then\n                    if databank then\n                        dataBankFlowers[data.fn] = nil\n                    end\n                end\n\n                saveToDataBank(\"_Flowers_\", dataBankFlowers)\n\n                updateDataBankCache()\n            else\n                system.print(\"Failed to delete patch |\" .. data.fn .. \"_\" .. data.patch .. \"|\")\n            end\n\n            if #flower.p == 0 then\n                sendFlowersInformation(screen)\n            else\n                sendFlowerInformation(screen, data.fn)\n            end\n        end\n    else\n        local dataBankFlowers = loadFromDataBank(\"_Flowers_\")\n        if dataBankFlowers then\n            local flower = dataBankFlowers[data.fn]\n            if databank then\n                dataBankFlowers[data.fn] = nil\n            end\n            saveToDataBank(\"_Flowers_\", dataBankFlowers)\n            if databank then\n                for _, patchName in pairs(flower.p) do\n                    databank.clearValue(data.fn .. \"_\" .. patchName)\n                end\n            end\n\n            updateDataBankCache()\n        end\n        sendFlowersInformation(screen)\n    end\nend\n\nfunction processScreenRequest(screen, data)\n    if data.type == \"patch\" then\n\n        local patchData = getPatchInformationFromDatabank(data.flower, data.patch)\n\n        if patchData ~= nil then\n            local miners = {}\n            local ores = {}\n\n            local time = 0\n            for index, miner in ipairs(patchData.miners) do\n\n                if not ores[miner.oid] then\n                    local item_data = system.getItem(miner.oid)\n                    ores[miner.oid] = {\n                        item_data.locDisplayName,\n                        item_data.iconPath:gsub(\"resources_generated/env/\", \"\")\n                    }\n                end\n\n                --miner.on = item_data.locDisplayName\n                --miner.oi = item_data.iconPath:gsub(\"resources_generated/env/\", \"\")\n                miner.pn = getPlayerName(miner.pid)\n\n                miners[#miners + 1] = {\n                    miner.s, -- 1 State\n                    miner.r, -- 2 Rate\n                    miner.c, -- 3 Calibration\n                    miner.o, -- 4 Optimal\n                    miner.e, -- 5 efficientcy\n                    miner.pid, -- 6 player ID\n                    miner.et, -- 7 extraction time\n                    miner.lv, -- 8 last Volume\n                    miner.oid, -- 9 ore ID\n                    miner.pn -- 10 Player name\n                }\n            end\n\n            local patchInformation = {}\n            patchInformation.type = \"patch\"\n            patchInformation.name = data.patch\n            patchInformation.miners = miners\n            patchInformation.time = patchData.time\n            patchInformation.ores = ores\n\n            if patchData.c then\n                local mass, vol = estimateContainerContents(patchData.c, patchData)\n                patchInformation.c = {\n                    mass,\n                    patchData.c.maxVol,\n                    vol\n                }\n            end\n\n            patchInformation.t = system.getArkTime()\n\n            screen.setScriptInput(serialize(patchInformation))\n        end\n\n        lastScreenRequest = data\n    elseif data.type == \"flowers\" then\n        sendFlowersInformation(screen)\n        lastScreenRequest = data\n    elseif data.type == \"flower\" then\n        sendFlowerInformation(screen, data.flowerName)\n        lastScreenRequest = data\n    elseif data.type == \"closest\" then\n        sendClosestInfoToScreens(screen)\n    end\nend\n\nfunction updateFlowerGroups(flowerName)\n\n    local flower = dataBankFlowers[flowerName]\n\n    if not flower then\n        return\n    end\n\n    local group = 1\n\n    for _, patchName in pairs(flower.p) do\n        local patchData = getPatchInformationFromDatabank(flowerName, patchName)\n        if not patchData.g then\n            patchData.g = group\n            local patchCenter = getPatchCenter(flowerName, patchName)\n            for _, checkPatchName in pairs(flower.p) do\n                if patchName ~= checkPatchName then\n                    local checkPatchData = getPatchInformationFromDatabank(flowerName, checkPatchName)\n                    if not checkPatchData.g then\n                        local checkPatchCenter = getPatchCenter(flowerName, checkPatchName)\n                        local distance = getDistance(checkPatchCenter, patchCenter)\n                        if distance < patchGroupDistance then\n                            checkPatchData.g = group\n                        end\n                    end\n                end\n            end\n            group = group + 1\n        end\n    end\nend\n\nlocal cachedCenters = {}\n\nfunction getFlowerGroupCenter(flowerName, group)\n\n    local old = cachedCenters[flowerName]\n\n    if not old then\n        cachedCenters[flowerName] = {}\n    end\n\n    if old and old[group] then\n        return old[group]\n    end\n\n    local locations = {}\n\n    local flower = dataBankFlowers[flowerName]\n\n    for _, patchName in pairs(flower.p) do\n        local patchData = getPatchInformationFromDatabank(flowerName, patchName)\n        if patchData.g and patchData.g == group then\n            locations[#locations + 1] = patchData.center\n        end\n    end\n\n    if #locations == 0 then\n        return nil\n    end\n\n    local center = getCenter(locations)\n\n    cachedCenters[flowerName][group] = center\n\n    return center\nend\n\nfunction patchesForAR(closestFlower, closestPatches)\n\n    local patches = {}\n\n    local playerLoc = player.getWorldPosition()\n\n    local fullestContainer = -1\n\n    updateFlowerGroups(closestFlower)\n\n    for i = 1, #closestPatches do\n\n        local patchInfo = closestPatches[i]\n\n        if patchInfo then\n            local patchData = getPatchInformationFromDatabank(closestFlower, patchInfo.name)\n            if patchData ~= nil then\n                local m = patchData.miners\n                local miners = {}\n\n                local patchCenter = getPatchCenter(closestFlower, patchInfo.name)\n\n                for index, miner in ipairs(m) do\n                    if not ores[miner.oid] then\n                        local item_data = system.getItem(miner.oid)\n                        ores[miner.oid] = { name = item_data.locDisplayName, icon = item_data.iconPath:gsub(\"resources_generated/env/\", \"\") }\n                    end\n                    local item_data = ores[miner.oid]\n                    miner.on = item_data.name\n                    miner.oi = item_data.icon\n                    miners[#miners + 1] = miner\n                end\n                if #miners > 0 then\n                    local distance = getDistance(playerLoc, patchCenter)\n\n                    patches[#patches + 1] = {\n                        name = patchInfo.name,\n                        center = patchCenter,\n                        distance = distance,\n                        miners = miners,\n                        time = patchData.time\n                    }\n\n                    if patchData.g then\n                        patches[#patches].g = {\n                            g = patchData.g,\n                            c = getFlowerGroupCenter(closestFlower, patchData.g),\n                            d = getDistance(playerLoc, patches[#patches].gc)\n                        }\n\n                    end\n\n                    if patchData.c then\n\n                        local mass, vol = estimateContainerContents(patchData.c, patchData)\n\n                        if fullestContainer < vol * 100 / patchData.c.maxVol then\n                            fullestContainer = vol * 100 / patchData.c.maxVol\n                        end\n\n                        patches[#patches].c = {\n                            mass = mass,\n                            vol = vol,\n                            maxVol = patchData.c.maxVol,\n                            l = patchData.c.l\n                        }\n                    end\n                end\n            end\n        end\n    end\n\n    table.sort(patches, function(k1, k2)\n        return k1.distance > k2.distance\n    end)\n\n    return patches, fullestContainer\nend\n\nfunction updateAR()\n\n    local patches, fullestContainer = patchesForAR(closestFlower, closestPatches)\n\n    local info = {}\n    info.center = getFlowerCenter(closestFlower)\n    info.patches = patches\n    info.name = closestFlower\n    info.container = fullestContainer\n\n    sendClosestInfoToScreens()\n    previousClosests = currentClosests\n    minerInfo(info)\nend\n\nfunction update()\n\n    getClosestFlower()\n    getClosestPatches()\n    checkEnteredPatches()\n    checkAlive()\n\n    if closestFlower and #closestPatches > 0 and currentClosests ~= previousClosests then\n        cachedCenters = {}\n        updateAR()\n    end\n\n    for id, screenObject in ipairs(screens) do\n        local output = screenObject.screen.getScriptOutput()\n        if output and screenOutput ~= output then\n            local data = deserialize(output)\n            if data and data.type then\n                if data.type == \"location\" then\n\n                    if data.id then\n                        local patchData = getPatchInformationFromDatabank(data.fn, data.patch)\n                        if patchData and patchData.miners and patchData.miners[data.id] then\n                            system.setWaypoint(convertVecToPos(vec3(patchData.miners[data.id].l)))\n                        end\n                    elseif data.patch then\n                        local centerLoc = getPatchCenter(data.fn, data.patch)\n                        system.setWaypoint(convertVecToPos(vec3(centerLoc)))\n                    else\n                        local centerLoc = getFlowerCenter(data.fn)\n                        system.setWaypoint(convertVecToPos(vec3(centerLoc)))\n                    end\n                elseif data.type == \"delete\" then\n                    deleteRecord(screenObject.screen, data)\n                elseif data.type == \"screenEdit\" then\n                    receivedScreenEditData(screenObject.screen, data)\n                    screenObject.screen.clearScriptOutput()\n                else\n                    processScreenRequest(screenObject.screen, data)\n                end\n            end\n            screenOutput = output\n        end\n    end\nend\n\nfunction syncMiners()\n\n    if not transmitter then\n        return\n    end\n\n    minerRequestDataNames = {}\n\n    if closestFlower and #closestPatches > 0 then\n        local miners = {}\n        for i = 1, #closestPatches do\n            local patchInfo = closestPatches[i]\n            if patchInfo then\n                minerRequestDataNames[#minerRequestDataNames + 1] = { name = closestFlower .. \"_\" .. patchInfo.name, cycle = 0 }\n            end\n        end\n    end\n\n    unit.setTimer(\"requestMinerData\", 0.1)\nend\n\nfunction requestMinerData()\n\n    if #minerRequestDataNames == 0 then\n        unit.stopTimer(\"requestMinerData\")\n        return\n    end\n\n    if minerRequestDataNames[1].cycle > 1 then\n        table.remove(minerRequestDataNames, 1)\n    end\n\n    if #minerRequestDataNames == 0 then\n        unit.stopTimer(\"requestMinerData\")\n        return\n    end\n\n    local name = emitterChannel .. \"_\" .. minerRequestDataNames[1].name\n    transmitter.send(name, \"DataRequest\")\n    minerRequestDataNames[1].cycle = minerRequestDataNames[1].cycle + 1\nend\n\nfunction onStop()\n    brakeLink()\n    saveToDataBank(\"Settings\", settings)\n    local data = serialize({\n        type = \"shutdown\"\n    })\n    for id, screenObject in ipairs(screens) do\n        screenObject.screen.setScriptInput(data)\n    end\nend\n\nholdingShift = false\n\n-- Show AR\nif settings.SAR == nil then\n    settings.SAR = true\nend\n-- Show AR distant\nif settings.SARD == nil then\n    settings.SARD = true\nend\n\n-- Show AR planets\nif settings.SARP == nil then\n    settings.SARP = true\nend\n-- Enable inputs\nif settings.ei == nil then\n    settings.ei = true\nend\n\n--if settings.autoSyncToggle == nil then\n--    settings.autoSyncToggle = 1\n--end\n\nfunction keyAction(mode, action)\n\n    if not linkedMaster then\n        return\n    end\n\n    if mode == \"stop\" then\n        if settings.enableInputs then\n            if action == \"option1\" then\n                syncMiners()\n                --elseif action == \"option2\" then\n                --    settings.autoSyncToggle = settings.autoSyncToggle + 1\n                --    if settings.autoSyncToggle > 4 then\n                --        settings.autoSyncToggle = 1\n                --    end\n            elseif action == \"option3\" then\n                settings.SAR = not settings.SAR\n            elseif action == \"option4\" then\n                settings.SARD = not settings.SARD\n            elseif action == \"option5\" then\n                settings.SARP = not settings.SARP\n            end\n        end\n\n        if action == \"leftmouse\" and lookingAt and lookingAt.lookingAtDistance and lookingAt.lookingAtDistance < 2 then\n            system.setWaypoint(convertVecToPos(vec3(lookingAt.center)))\n        end\n\n        if action == \"option9\" then\n            settings.ei = not settings.ei\n        end\n    end\n\n    if action == \"lshift\" then\n        if mode == \"stop\" then\n            holdingShift = false\n        elseif mode == \"start\" then\n            holdingShift = true\n        end\n    end\nend\n\nlocal dataBankcapacity = 0\n\nif databank then\n    for id, key in ipairs(databank.getKeyList()) do\n        dataBankcapacity = dataBankcapacity + string.len(key)\n        dataBankcapacity = dataBankcapacity + string.len(databank.getStringValue(key))\n        dataBankcapacity = dataBankcapacity + 5\n    end\nend\n\nsystem.print(\"-----------------------------------\")\nif miningPost then\n    system.print(\"Mining platform\")\n    system.print(\"Mining units: \" .. #miningUnits)\n    if container then\n        system.print(\"Container: \" .. tostring(container ~= nil))\n    end\nelse\n    system.print(\"Mining ship\")\nend\n\ntemptext = \"\"\n\ntemptext = temptext .. \"Screens: \" .. #screens\n\nif databank then\n    system.print(\"Databank filled: \" .. dataBankcapacity .. \" (~\"..round(dataBankcapacity / 300, 1)..\"%)\")\nend\nif transmitter then\n    temptext = temptext .. \" Emitter: \" .. tostring(transmitter ~= nil)\nend\nif receiver then\n    temptext = temptext .. \" Receiver: \" .. tostring(receiver ~= nil)\nend\nsystem.print(temptext)\nsystem.print(\"-----------------------------------\")\n\ndataSyncHandShake()\nunit.setTimer(\"update\", 0.1)\n\nunit.hideWidget()","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"1"},{"code":"  --databank.clear()\nonStop()","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"2"},{"code":"update()","filter":{"args":[{"value":"update"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"3"},{"code":"requestMinerData()","filter":{"args":[{"value":"requestMinerData"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"4"},{"code":"dataSync()","filter":{"args":[{"value":"sync"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"5"},{"code":"minerInfo()","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"6"},{"code":"keyAction(\"stop\", action)","filter":{"args":[{"variable":"*"}],"signature":"onActionStop(action)","slotKey":"-4"},"key":"7"},{"code":"keyAction(\"start\", action)","filter":{"args":[{"variable":"*"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"8"},{"code":"---\n--- Created by Zrips.\n--- DateTime: 2022-12-04 16:12\n---\n---\n\nlocal smallestOpacity = 0.5\n\nlocal flowerInfoRange = 10000\nlocal hideFrom = 4000\nlocal fullVisibleFrom = 3000\nlocal mergedBoxFrom = 120\nlocal splitBoxFrom = 60\nlocal biggerBoxFrom = 30\n\nlocal edgeOpacityFade = 0.1\n\nlocal toShow = {}\n\norangeColorHex = \"#FECC00\"\nredColorHex = \"#FE4500\"\ncyanColorHex = \"#87ceff\"\nwhiteColorHex = \"#ffffff\"\ngreenColorHex = \"#049F00\"\n\nlocal css = [[ <style>\n            .element {\n             background: #0d181c;\n             border-style: solid;\n             border-color: ]] .. cyanColorHex .. [[;\n             border-width: 1px;\n             transform: translate(-50%,-50%);\n             position: fixed;\n             padding: 2px 2px 2px 2px;\n             font-size: 0.6em;\n             color: ]] .. cyanColorHex .. [[;\n             line-height: 1;\n             border-radius: 3px 3px 3px 3px;\n             z-index: 1;\n            }\n            .wraper {\n             width: 100%;\n             min-width: 50px;\n            }\n\n            .stacked {\n              float: left;\n              margin: 0px 5px 0px 5px;\n            }\n\n            .vl {\n              border-left: 1px solid ]] .. cyanColorHex .. [[;\n              position: absolute;\n              top: 10%;\n              bottom: 10%;\n              transform: translate(-10px,0%);\n              opacity: 0.5;\n            }\n\n            .progress-bar {\n             width: 100%;\n             background-color: #0d181c;\n             border-style: solid;\n             border-color: ]] .. cyanColorHex .. [[;\n             border-width: 0px;\n             padding: 0px 0px 0px 0px;\n             border-radius: 0px 0px 0px 0px;\n            }\n\n            .progress-bar-fill {\n             display: block;\n             height: 5px;\n             background-color: #fad47a;\n             border-radius: 0px 0px 0px 0px;\n            }\n            </style>\n]]\n\nfunction generateOptimizedBlock(x, y, options, texts)\n\n    local html = [[<div class=\"element\" style = \"top: ]] .. y .. [[%; left: ]] .. x .. [[%; opacity: ]] .. (options.opacity or 1) .. [[; z-index: ]] .. (options.zIndex or 0) .. [[; color: ]] .. (options.color or cyanColorHex) .. [[; border-color: ]] .. (options.borderColor or cyanColorHex) .. [[; border-width: ]] .. (options.borderWidth or 1) .. [[px;\">]]\n\n    for id, block in ipairs(texts) do\n\n        if block[1] then\n            if options.centered then\n                html = html .. [[<center>]] .. block[1] .. [[</center>]]\n            else\n                html = html .. block[1]\n                if id ~= #texts then\n                    html = html .. \"<br>\"\n                end\n            end\n        end\n\n        if block[2] then\n            html = html .. [[<div class=\"wraper\">\n                                <div class=\"progress-bar\">\n                                    <span class=\"progress-bar-fill\" style=\"width: ]] .. mmin(block[2], 100) .. [[%;\"></span>\n                                </div>\n                            </div>]]\n\n        end\n    end\n\n    html = html .. [[</div>]]\n    return html\nend\n\nfunction generateBlock(x, y, opacity, text, progress, center, text2, zIndex, borderColor)\n\n    if not borderColor then\n        borderColor = cyanColorHex\n    end\n\n    local html = [[<div class=\"element\" style = \"top: ]] .. y .. [[%; left: ]] .. x .. [[%; opacity: ]] .. opacity .. [[; border-color: ]] .. borderColor .. [[;\">]]\n\n    if zIndex then\n        html = [[<div class=\"element\" style = \"top: ]] .. y .. [[%; left: ]] .. x .. [[%; opacity: ]] .. opacity .. [[; z-index: ]] .. zIndex .. [[;\">]]\n    end\n\n    if text then\n        if center then\n            html = html .. [[<center>]] .. text .. [[</center>]]\n        else\n            html = html .. text\n        end\n    end\n\n    if progress then\n        html = html .. [[<div class=\"wraper\">\n    <div class=\"progress-bar\">\n    <span class=\"progress-bar-fill\" style=\"width: ]] .. mmin(progress, 100) .. [[%;\"></span>\n    </div>\n    </div>]]\n    end\n\n    if text2 then\n        if center then\n            html = html .. [[<center>]] .. text2 .. [[</center>]]\n        else\n            html = html .. text2\n        end\n    end\n\n    html = html .. [[</div>]]\n    return html\nend\n\nfunction generateTextBlock(x, y, opacity, text, fontSize, center)\n    local html = [[\n    <div class=\"element\" style = \"top: ]] .. y .. [[%; left: ]] .. x .. [[%; opacity: ]] .. opacity .. [[; font-size: ]] .. fontSize .. [[em;\">]]\n    if text then\n        if center then\n            html = html .. [[<center>]] .. text .. [[</center>]]\n        else\n            html = html .. text\n        end\n    end\n    html = html .. [[</div>]]\n    return html\nend\n\nfunction formatFootNote(state, alt, text)\n    if alt then\n        if state then\n            return [[Alt+]] .. alt .. [[ - ]] .. text\n        else\n            return [[<span style=\"color: ]] .. orangeColorHex .. [[;\">Alt+]] .. alt .. [[ - ]] .. text .. [[</span>]]\n        end\n    else\n        if state then\n            return [[<span style=\"text-align: right;\">]] .. text .. [[</span>]]\n        else\n            return [[<span style=\"color: ]] .. orangeColorHex .. [[; text-align: right;\">]] .. text .. [[</span>]]\n        end\n    end\nend\n\nfunction generateFootNote()\n    local text = {}\n\n    text[#text + 1] = formatFootNote(true, nil, version)\n    if linkedTo.id then\n        text[#text + 1] = construct.getName() .. \" -> \" .. linkedTo.construct\n    else\n        text[#text + 1] = construct.getName()\n    end\n\n    text[#text + 1] = \"Alt+1 - Sync nearby miners\"\n\n    text[#text + 1] = \"...\"\n\n    text[#text + 1] = formatFootNote(settings.showAR, 3, \"Toggle AR mode\")\n    text[#text + 1] = formatFootNote(settings.showARDistant, 4, \"Show AR for distant flowers\")\n    text[#text + 1] = formatFootNote(settings.showARPlanets, 5, \"Show AR on another planets\")\n\n    text[#text + 1] = \"...\"\n\n    text[#text + 1] = formatFootNote(settings.enableInputs, 9, \"Toggle short key inputs\")\n\n    local lines = { }\n    for id, t in ipairs(text) do\n        lines[#lines + 1] = { t }\n    end\n\n    local progress = nil\n\n    local masterP, slaveP = getSyncProgress()\n\n    if masterP >= 0 then\n        if masterP < 100 then\n            progress = masterP\n        else\n            progress = slaveP\n        end\n    end\n\n    lines[#lines + 1] = { \"\", progress }\n\n    local opacity = 0.7\n    if not settings.enableInputs then\n        opacity = 0.5\n    end\n\n    inScreen = true\n\n    return generateOptimizedBlock(footNoteX, footNoteY, { opacity = opacity }, lines)\nend\n\nfunction getDistance(fromVector, center)\n    if not fromVector or not center or #fromVector ~= 3 or #center ~= 3 then\n        return 999999999999\n    end\n    return tonumber(string.format(\"%.2f\", math.sqrt((fromVector[1] - center[1]) ^ 2 + (fromVector[2] - center[2]) ^ 2 + (fromVector[3] - center[3]) ^ 2)))\nend\n\nfunction getOpacityByEdge(x, y, opacity)\n\n    local value = -1\n\n    if x < edgeOpacityFade then\n        value = x\n    end\n\n    if x > 1 - edgeOpacityFade then\n        value = 1 - x\n    end\n\n    if y < edgeOpacityFade then\n        value = value == -1 and y or mmin(value, y)\n    end\n\n    if y > 1 - edgeOpacityFade then\n        value = value == -1 and 1 - y or mmin(value, 1 - y)\n    end\n\n    if value == -1 then\n        return opacity\n    end\n\n    return (opacity * (value / edgeOpacityFade))\nend\n\nfunction getFlowerOpacity(toPlayer, x, y)\n    return getOpacityByEdge(x, y, 0.5)\nend\n\nfunction getMinerInfoForAR(miner, time)\n\n    if not time then\n        time = system.getArkTime()\n    end\n\n    local estimateCalib = estimateCalibration(miner.c, miner.et, time, true)\n\n    local fromLastUpdate = system.getArkTime() - time\n\n    local nextCalTime = timeUntilReCalibration(estimateCalib, miner.et, time, mmin(miner.o, minimalCalibration))\n    local nextCalText = \"\"\n    if nextCalTime < 0 or estimateCalib < mmin(miner.o, minimalCalibration) and fromLastUpdate + miner.et > 60 * 60 * 24 then\n        nextCalText = \"Calibrate!\"\n    else\n        nextCalText = secondsToClockString(nextCalTime, true)\n    end\n\n    local color = \"#fff\"\n\n    if fromLastUpdate + miner.et > 60 * 60 * 24 * 3 then\n        if estimateCalib < mmin(miner.o, minimalCalibration) then\n            color = \"#FE4500\"\n        else\n            color = \"#FECC00\"\n        end\n    end\n\n    return {\n        calibration = round(estimateCalib, 2),\n        calibrationTime = nextCalText,\n        color = color\n    }\nend\n\nlookingAt = {}\n\nfunction distance (x1, y1, x2, y2)\n    local dx = x1 - x2\n    local dy = y1 - y2\n    return msqrt(dx * dx + dy * dy)\nend\n\nfunction getDistantFlowersSVG()\n\n    if not settings.showARDistant then\n        return \"\"\n    end\n\n    local playerLoc = player.getWorldPosition()\n\n    local flowersInfo = {}\n\n    lookingAt = {\n        lookingAtDistance = 99999\n    }\n\n    for name, f in pairs(dataBankFlowers) do\n        local center = getFlowerCenter(name)\n        local dist = getDistance(playerLoc, center)\n        if closestFlower ~= name or dist > flowerInfoRange then\n\n            -- 2 SU range to filter out mining sites on another planets\n            if settings.showARPlanets or not settings.showARPlanets and dist < 1000 * 200 * 2 then\n\n                local screenPos = library.getPointOnScreen(center)\n                local lx = screenPos[1] * 100\n                local ly = screenPos[2] * 100\n\n                local distance = distance(50, 50, lx, ly)\n\n                if distance < lookingAt.lookingAtDistance then\n                    lookingAt.lookingAtDistance = distance\n                    lookingAt.lookingAt = name\n                    lookingAt.distanceToFlower = dist\n                    lookingAt.center = center\n                end\n\n                local planet = getFlowerPlanet(name)\n\n                local flowerInfo = flowersInfo[planet] or {}\n\n                flowerInfo[#flowerInfo + 1] = {\n                    name = name,\n                    distance = dist,\n                    center = center,\n                    pos = { lx, ly }\n                }\n\n                flowersInfo[planet] = flowerInfo\n            end\n        end\n    end\n\n    local boxWidth = 6\n    local boxHeight = 2\n\n    local svg = \"\"\n\n    local options = {\n        centered = true,\n        borderWidth = 1,\n        color = whiteColorHex\n    }\n\n    for id, flowerInfo in pairs(flowersInfo) do\n        local distance = nil\n        local screenPos = nil\n\n        local planet = {  }\n\n        for ids, info in pairs(flowerInfo) do\n            if not lookingAt or lookingAt.lookingAt ~= info.name or lookingAt.lookingAtDistance > 2 then\n\n                if #planet == 0 then\n                    planet[#planet + 1] = { \"Planet: \" .. getFlowerPlanet(info.name) }\n                end\n\n                if distance == nil then\n                    distance = info.distance\n                end\n\n                if screenPos == nil then\n                    screenPos = library.getPointOnScreen(info.center)\n                end\n\n                if info.distance <= 2000000 then\n\n                    screenPos = library.getPointOnScreen(info.center)\n                    local lx = screenPos[1] * 100\n                    local ly = screenPos[2] * 100\n                    if lx > 0 and lx < 100 and ly > 0 and ly < 100 then\n\n                        options.borderColor = whiteColorHex\n                        options.opacity = getOpacityByEdge(lx / 100, ly / 100, 0.4)\n\n                        svg = svg .. generateOptimizedBlock(lx, ly, options, { { info.name }, { formatDistance(info.distance) } })\n                        inScreen = true\n                    end\n                else\n                    planet[#planet + 1] = { info.name }\n                end\n            end\n        end\n\n        if #planet > 1 then\n            local lx = screenPos[1] * 100\n            local ly = screenPos[2] * 100\n\n            if lx > 0 and lx < 100 and ly > 0 and ly < 100 then\n\n                if distance > 2000000 then\n                    options.borderColor = orangeColorHex\n                    options.borderWidth = 2\n                    options.opacity = getOpacityByEdge(lx / 100, ly / 100, 0.2)\n                else\n                    options.borderColor = whiteColorHex\n                    options.opacity = getOpacityByEdge(lx / 100, ly / 100, 0.4)\n                end\n\n                planet[#planet + 1] = { formatDistance(distance) }\n\n                svg = svg .. generateOptimizedBlock(lx, ly, options, planet)\n                inScreen = true\n            end\n        end\n    end\n\n    if lookingAt and lookingAt.lookingAtDistance < 2 then\n\n        local toShow = {}\n\n        toShow.center = lookingAt.center\n        local dataBankFlowers = loadFromDataBank(\"_Flowers_\")\n\n        local patches = {}\n\n        for id, name in pairs(dataBankFlowers[lookingAt.lookingAt].p) do\n            patches[#patches + 1] = { name = name }\n        end\n\n        toShow.patches, toShow.container = patchesForAR(lookingAt.lookingAt, patches)\n        toShow.distance = lookingAt.distanceToFlower\n        toShow.name = lookingAt.lookingAt\n\n        svg = svg .. generateFlowerBigBlock(toShow, 10)\n    end\n\n    return svg\nend\n\nfunction generateFlowerBigBlock(toShow, zIndex)\n\n    local svg = \"\"\n    local screenPos = library.getPointOnScreen(toShow.center)\n    local lx = screenPos[1] * 100\n    local ly = screenPos[2] * 100\n    if lx > 0 and lx < 100 and ly > 0 and ly < 100 then\n\n        local maxMiners = 1\n        local patchInfo = {}\n\n        local mass = 0\n        local volume = 0\n\n        for id, patch in ipairs(toShow.patches) do\n            --local patchCenter = patch.center\n            --local toPlayer = patch.distance\n            local minerInfo = {}\n            local minerCount = 0\n            for _, miner in ipairs(patch.miners) do\n                minerCount = minerCount + 1\n                minerInfo[#minerInfo + 1] = getMinerInfoForAR(miner, patch.time)\n            end\n\n            if minerCount > maxMiners then\n                maxMiners = minerCount\n            end\n\n            patchInfo[#patchInfo + 1] = {\n                minerInfo = minerInfo\n            }\n\n            if patch.c then\n                mass = mass + patch.c.mass\n                volume = volume + patch.c.vol\n            end\n        end\n\n        local opacity = getOpacityByEdge(lx / 100, ly / 100, 0.9)\n\n        local text = \"\"\n        for id, pi in ipairs(patchInfo) do\n            if string.len(text) > 0 then\n                text = text .. \"<br>\"\n            end\n            for place, info in ipairs(pi.minerInfo) do\n                if string.len(text) > 0 then\n                    text = text .. \" \"\n                end\n                text = text .. [[<span style=\"color: ]] .. info.color .. [[;\">]] .. mfloor(info.calibration) .. \"</span>\"\n            end\n        end\n\n        local fullest = toShow.container\n\n        local containerInfo = \"\"\n\n        if fullest < 0 then\n            fullest = nil\n        else\n            local massText = \"\"\n            if mass > 1000 then\n                massText = tostring(mceil(mass / 1000))\n            else\n                volText = round(mass / 1000, 2)\n            end\n\n            local volText = \"\"\n            if volume > 1000 then\n                volText = mceil(volume / 1000)\n            else\n                volText = round(volume / 1000, 2)\n            end\n\n            containerInfo = \"<br>\" .. massText .. \"T &nbsp;&nbsp;&nbsp;\" .. volText .. \"KL\"\n        end\n\n        svg = svg .. generateBlock(lx, ly, opacity, toShow.name .. \"<br>\" .. text .. containerInfo, fullest, true, formatDistance(toShow.distance), zIndex)\n\n        inScreen = true\n    end\n    return svg\nend\n\nfunction generateCloseFlowerInfo()\n\n    if not toShow or not toShow.center then\n        return \"\"\n    end\n\n    local playerLoc = player.getWorldPosition()\n\n    local svg = \"\"\n\n    local toFlowerCenter = mfloor(getDistance(playerLoc, toShow.center))\n\n    toShow.distance = toFlowerCenter\n\n    if toFlowerCenter > hideFrom and toFlowerCenter < flowerInfoRange then\n        return generateFlowerBigBlock(toShow)\n    else\n\n        local groups = {}\n\n        for pid, patch in ipairs(toShow.patches) do\n            local toPlayer = patch.distance\n\n            if patch.g then\n                toPlayer = mfloor(getDistance(playerLoc, patch.g.c))\n            end\n            if toPlayer >= mergedBoxFrom and (toPlayer <= hideFrom or toFlowerCenter <= hideFrom) then\n                local group = groups[patch.g.g]\n                if not group then\n                    group = {}\n                end\n                patch.g.d = toPlayer\n                group[#group + 1] = patch\n                groups[patch.g.g] = group\n            end\n        end\n\n        local options = {\n            centered = true,\n            borderColor = borderColor,\n            borderWidth = borderWidth\n        }\n\n        for pid, group in pairs(groups) do\n\n\n            local groupCenter = group[1].g.c\n\n            local screenPos = library.getPointOnScreen(groupCenter)\n            local lx = screenPos[1] * 100\n            local ly = screenPos[2] * 100\n\n            if lx > 0 and lx < 100 and ly > 0 and ly < 100 then\n\n\n                local lines = { }\n\n                local distance = 9999999\n                local time = 0\n\n                options.opacity = getOpacityByEdge(lx / 100, ly / 100, 0.6)\n\n                for id, patch in pairs(group) do\n\n                    local minerInfo = {}\n\n                    for id, miner in ipairs(patch.miners) do\n                        minerInfo[#minerInfo + 1] = getMinerInfoForAR(miner, patch.time)\n                    end\n\n                    if time < system.getArkTime() - patch.time then\n                        time = system.getArkTime() - patch.time\n                    end\n                    if distance > patch.g.d then\n                        distance = patch.g.d\n                    end\n\n                    local text = \"\"\n                    for id, info in ipairs(minerInfo) do\n                        text = text .. [[<span style=\"color: ]] .. info.color .. [[;\">]] .. mfloor(info.calibration) .. [[</span> ]]\n                    end\n\n                    local percentage = nil\n                    if patch.c then\n                        percentage = (patch.c.vol / patch.c.maxVol) * 100\n                    end\n\n                    lines[#lines + 1] = { text, percentage }\n\n                end\n\n                lines[#lines + 1] = { secondsToClockString(time, true) }\n                lines[#lines + 1] = { formatDistance(distance) }\n\n                svg = svg .. generateOptimizedBlock(lx, ly, options, lines)\n                inScreen = true\n\n            end\n        end\n\n        for pid, patch in ipairs(toShow.patches) do\n\n            local patchCenter = patch.center\n            local toPlayer = patch.distance\n\n            if patch.g then\n                patchCenter = patch.g.c\n            end\n\n            toPlayer = mfloor(getDistance(playerLoc, patchCenter))\n\n            local borderColor = nil\n            local borderWidth = nil\n\n            if system.getArkTime() - patch.time < 5 then\n                borderColor = greenColorHex\n                borderWidth = 2\n            end\n\n            local options = {\n                centered = true,\n                borderColor = borderColor,\n                borderWidth = borderWidth\n            }\n\n            if toPlayer > splitBoxFrom and toPlayer < mergedBoxFrom then\n\n                local screenPos = library.getPointOnScreen(patch.center)\n                local lx = screenPos[1] * 100\n                local ly = screenPos[2] * 100\n\n                toPlayer = mfloor(getDistance(playerLoc, patch.center))\n\n                if toPlayer < hideFrom and lx > 0 and lx < 100 and ly > 0 and ly < 100 then\n\n                    local minerInfo = {}\n                    for id, miner in ipairs(patch.miners) do\n                        minerInfo[#minerInfo + 1] = getMinerInfoForAR(miner, patch.time)\n                    end\n\n                    options.opacity = getOpacityByEdge(lx / 100, ly / 100, 0.7)\n                    local timeFromUpdate = secondsToClockString(system.getArkTime() - patch.time, true)\n\n                    local lines = {}\n\n                    local text = \"\"\n\n                    for id, info in ipairs(minerInfo) do\n                        text = text .. [[<span style=\"color: ]] .. info.color .. [[;\">]] .. mfloor(info.calibration) .. [[</span> ]]\n                    end\n\n                    local percentage = nil\n                    if patch.c then\n                        percentage = (patch.c.vol / patch.c.maxVol) * 100\n                    end\n\n                    lines[#lines + 1] = { text, percentage }\n\n                    lines[#lines + 1] = { timeFromUpdate }\n                    lines[#lines + 1] = { formatDistance(toPlayer) }\n\n                    svg = svg .. generateOptimizedBlock(lx, ly, options, lines)\n                    inScreen = true\n                end\n\n            elseif toPlayer <= splitBoxFrom then\n\n\n                toPlayer = mfloor(getDistance(playerLoc, patch.center))\n\n                for id, miner in ipairs(patch.miners) do\n                    miner.distance = getDistance(playerLoc, miner.l)\n                end\n\n                table.sort(patch.miners, function(k1, k2)\n                    return k1.distance > k2.distance\n                end)\n\n                if patch.c then\n                    local screenPos = library.getPointOnScreen(patch.c.l)\n                    local lx = screenPos[1] * 100\n                    local ly = screenPos[2] * 100\n                    if lx > 0 and lx < 100 and ly > 0 and ly < 100 then\n                        options.opacity = getOpacityByEdge(lx / 100, ly / 100, 0.8)\n\n                        local percentage = patch.c.vol / patch.c.maxVol\n\n                        --if toPlayer < 20 then\n                        --    system.print(\"Vol \".. patch.c.vol .. \" / \"..patch.c.maxVol)\n                        --end\n\n                        if toPlayer < biggerBoxFrom then\n                            svg = svg .. generateOptimizedBlock(lx, ly, options, { { round(patch.c.mass / 1000, 2) .. \"T\", percentage * 100 } })\n                        else\n                            svg = svg .. generateOptimizedBlock(lx, ly, options, { { \"\", percentage * 100 } })\n                        end\n                        inScreen = true\n                    end\n                end\n\n                for id, miner in ipairs(patch.miners) do\n\n                    local screenPos = library.getPointOnScreen(miner.l)\n                    local lx = screenPos[1] * 100\n                    local ly = screenPos[2] * 100\n\n                    if borderColor == nil and table_has_value(enteredPatches, patch.name) then\n                        options.borderColor = orangeColorHex\n                    end\n\n                    if toPlayer < hideFrom and lx > 0 and lx < 100 and ly > 0 and ly < 100 then\n                        local minerInfo = getMinerInfoForAR(miner, patch.time)\n                        options.opacity = getOpacityByEdge(lx / 100, ly / 100, 0.9)\n\n                        if toPlayer < biggerBoxFrom then\n                            local text = \"\"\n                            if miner.oi and string.len(miner.oi) > 0 then\n                                text = text .. [[<img width=\"30\" height=\"30\" src=\"../../resources_generated/env/]] .. miner.oi .. [[\"><br>]]\n                            end\n                            text = text .. [[<span style=\"color: ]] .. minerInfo.color .. [[;\">]] .. mfloor(minerInfo.calibration) .. [[%</span>]]\n                            if minerInfo.calibrationTime ~= \"-\" then\n                                text = text .. \"<br>\" .. minerInfo.calibrationTime\n                            end\n                            svg = svg .. generateOptimizedBlock(lx, ly, options, { { text } })\n                        else\n                            svg = svg .. generateOptimizedBlock(lx, ly, options, { { [[<span style=\"color: ]] .. minerInfo.color .. [[;\">]] .. mfloor(minerInfo.calibration) .. \"%</span>\" } })\n                        end\n                        inScreen = true\n                    end\n                end\n\n            end\n        end\n    end\n\n    return svg\n\nend\n\nfunction minerInfo(patches)\n\n    if miningPost then\n        return\n    end\n\n    if patches then\n        toShow = patches\n    end\n\n    if not linkedMaster then\n        system.setScreen(\"\")\n        system.showScreen(false)\n        return\n    end\n\n    local html = css\n\n    if not settings.showAR then\n        system.setScreen(html .. generateFootNote())\n        system.showScreen(true)\n        return\n    end\n\n    inScreen = false\n\n    html = html .. getDistantFlowersSVG()\n    html = html .. generateCloseFlowerInfo()\n    html = html .. generateFootNote()\n    html = html .. generateLinkSVG()\n\n    if inScreen then\n        system.setScreen(html)\n        system.showScreen(true)\n    end\n\nend\n\n\n\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"9"},{"code":"---\n--- Created by Zrips.\n--- DateTime: 2022-11-10 15:11\n---\n\nmabs = math.abs\nmmin = math.min\nmmax = math.max\nmfloor = math.floor\nmceil = math.ceil\nmsqrt = math.sqrt\n\nfunction table.removekey(table, key)\n    local element = table[key]\n    table[key] = nil\n    return element\nend\n\nfunction table_contains(tbl, x)\n    for _, v in pairs(tbl) do\n        if v == x then\n            return true\n        end\n    end\n    return false\nend\n\nfunction table_has_value (tab, val)\n    for index, value in pairs(tab) do\n        if value == val then\n            return true\n        end\n    end\n    return false\nend\n\nfunction table_get_position (tab, val)\n    for index, value in pairs(tab) do\n        if value == val then\n            return index\n        end\n    end\n    return 0\nend\n\nfunction ContainerMaxVol(hp)\n    if hp > 49 and hp <= 123 then\n        vol = hub\n    elseif hp > 123 and hp <= 998 then\n        vol = (1000 + (1000 * (containerProficiency / 100)))\n    elseif hp > 998 and hp <= 7996 then\n        vol = (8000 + (8000 * (containerProficiency / 100)))\n    elseif hp > 7996 and hp <= 17315 then\n        vol = (64000 + (64000 * (containerProficiency / 100)))\n    elseif hp > 17315 and hp <= 34632 then\n        vol = (128000 + (128000 * (containerProficiency / 100)))\n    elseif hp > 34632 and hp <= 69266 then\n        vol = (256000 + (256000 * (containerProficiency / 100)))\n    elseif hp > 69266 then\n        vol = (512000 + (512000 * (containerProficiency / 100)))\n    end\n    return vol\nend\n\nfunction ContainerSelfMass(hp)\n    if hp > 49 and hp <= 123 then\n        sm = 55.8\n    elseif hp > 123 and hp <= 998 then\n        sm = 229.09\n    elseif hp > 998 and hp <= 7996 then\n        sm = 1280\n    elseif hp > 7996 and hp <= 17315 then\n        sm = 7420\n    elseif hp > 17315 and hp <= 34632 then\n        sm = 14840\n    elseif hp > 34632 and hp <= 69266 then\n        sm = 44210\n    elseif hp > 69266 then\n        sm = 88410\n    end\n    return sm\nend\n\nfunction OptimizedContainerMass(mass)\n    oMass = (mass + (mass * (containerOptimization / 100)))\n    return oMass\nend\n\nlocal concat = table.concat\nlocal sFormat = string.format\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = sFormat(\"[%q]=\", key)\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = sFormat(\"%q\", value)\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return sFormat(\"%q\", value)\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction deserialize(s)\n    return load(\"return \" .. s)()\nend\n\nfunction ConvertLocalToWorld(mu, offset)\n    if offset == nil then\n        offset = vec3({})\n    else\n        offset = vec3(offset)\n    end\n    local localCoord = vec3(mu.getPosition())\n    local xOffset = (localCoord.x + offset.x) * vec3(construct.getWorldRight())\n    local yOffset = (localCoord.y + offset.y) * vec3(construct.getWorldForward())\n    local zOffset = (localCoord.z + offset.z) * vec3(construct.getWorldUp())\n\n    local vect = xOffset + yOffset + zOffset + vec3(construct.getWorldPosition())\n\n    return { round(vect.x, 1), round(vect.y, 1), round(vect.z, 1) }\nend\n\nfunction secondsToClockString(time, skipSeconds)\n    if time == nil or time <= 0 then\n        return \"-\"\n    else\n        local days = mfloor(time / 86400)\n        local hours = mfloor((time % 86400) / 3600)\n        local minutes = mfloor((time % 3600) / 60)\n        local seconds = mfloor(time % 60)\n        str = \"\"\n        if days > 0 then\n            str = str .. days .. \"d \"\n        end\n        if hours > 0 then\n            str = str .. hours .. \"h \"\n        end\n        if minutes > 0 then\n            str = str .. minutes .. \"m \"\n        end\n        if not skipSeconds and seconds > 0 or string.len(str) == 0 then\n            str = str .. seconds .. \"s\"\n        end\n        return str\n    end\nend\n\nfunction calibrationRequiredTime(calibration, optimal)\n    return ((calibration - optimal) / 0.625) * 3600\nend\n\nfunction timeUntilCalibration(calibration, optimal, calTime)\n    local calibrationRequiredTime = calibrationRequiredTime(calibration, optimal)\n    if calTime > 259200 then\n        return calibrationRequiredTime\n    end\n    return calibrationRequiredTime + (259200 - calTime)\nend\n\nfunction timeUntilReCalibration(calibration, extractionTime, lastUpdate, optimal)\n    local fromExtraction = system.getArkTime() - lastUpdate + extractionTime\n\n    local calibrationRequiredTime = calibrationRequiredTime(calibration, optimal)\n    if fromExtraction > 259200 then\n        return calibrationRequiredTime\n    end\n    return calibrationRequiredTime + (259200 - fromExtraction)\nend\n\nfunction estimateCalibration(calibration, extractionTime, lastUpdate, noRound)\n\n    local fromExtraction = system.getArkTime() - lastUpdate + extractionTime\n\n    if fromExtraction <= 259200 then\n        return calibration\n    end\n\n    local timeWhileDropping = fromExtraction - 259200\n\n    if system.getArkTime() - lastUpdate < timeWhileDropping then\n        timeWhileDropping = system.getArkTime() - lastUpdate\n    end\n\n    local lostPercent = 0.625 * (timeWhileDropping / 3600)\n\n    calibration = calibration - lostPercent\n    if not noRound then\n        calibration = round(calibration, 2)\n    end\n\n    if calibration < 0 then\n        calibration = 0\n    end\n    return calibration\nend\n\nlocal ores = {}\n\nfunction OptimizedContainerMass(mass)\n    return (mass - (mass * (containerOptimization * 0.2) * 0.2))\nend\n\nfunction estimateContainerContents(container, patch)\n\n    if not container then\n        return 0, 0\n    end\n\n    local mass = container.mass\n    local vol = container.vol\n\n    local producedMass = 0\n    local producedVol = 0\n\n    for index, miner in ipairs(patch.miners) do\n\n        if not ores[miner.oid] then\n            local item_data = system.getItem(miner.oid)\n            ores[miner.oid] = {\n                mass = item_data.unitMass,\n                volume = item_data.unitVolume\n            }\n        end\n\n        local fromExtraction = system.getArkTime() - patch.time + miner.et\n\n        local hoursStatic = 0\n        local hoursDynamic = 0\n\n        if fromExtraction < 259200 then\n            hoursStatic = mfloor((system.getArkTime() - patch.time) / 3600)\n        else\n            hoursStatic = mfloor(72 - (miner.et / 3600))\n            hoursDynamic = mfloor((fromExtraction - 259200) / 3600)\n        end\n\n        local estimatedCalib = estimateCalibration(miner.c, miner.et, patch.time, true)\n\n        local rate = 0\n        if miner.c > 0 then\n            rate = (estimatedCalib / miner.c) * miner.r\n        end\n        local averageProduction = (rate + miner.r) / 2\n\n        local oreMass = ores[miner.oid].mass\n        if not oreMass then\n            oreMass = 0\n        end\n\n        local oreVol = ores[miner.oid].volume\n        if not oreVol then\n            oreVol = 0\n        end\n\n        producedMass = producedMass + OptimizedContainerMass((hoursStatic * (miner.r * oreMass)) + (hoursDynamic * (averageProduction * oreMass)))\n        producedVol = producedVol + (hoursStatic * (miner.r * oreVol)) + (hoursDynamic * (averageProduction * oreVol))\n    end\n\n    mass = mass + producedMass\n\n    if mass < 0 then\n        mass = 0\n    end\n\n    vol = vol + producedVol\n\n    if vol < 0 then\n        vol = 0\n    end\n\n    return mass, vol\nend\n\nfunction convertVecToPos(vecInput)\n    if vecInput.x then\n        return \"::pos{0,0,\" .. vecInput.x .. \",\" .. vecInput.y .. \",\" .. vecInput.z .. \"}\"\n    else\n        return \"::pos{0,0,\" .. vecInput[1] .. \",\" .. vecInput[2] .. \",\" .. vecInput[3] .. \"}\"\n    end\nend\n\nlocal forDelaySave = {}\n\nfunction saveToDataBank(key, data)\n    if not databank then\n        return\n    end\n\n    data = serialize(data):gsub(\"\\\"\", \"\\'\")\n    databank.setStringValue(key, data)\nend\n\nfunction recheckDataBankObject()\n    for slot_name, slot in pairs(unit) do\n        if type(slot) == \"table\" and type(slot.export) == \"table\" and slot.getClass then\n            local cl = slot.getClass()\n            if cl and cl:lower() == 'databankunit' then\n                databank = slot\n            end\n        end\n    end\nend\n\nfunction table.removeFirst(tbl, val)\n    for i, v in ipairs(tbl) do\n        if v == val then\n            return table.remove(tbl, i)\n        end\n    end\nend\n\nfunction table.removekey(table, key)\n    local element = table[key]\n    table[key] = nil\n    return element\nend\n\nfunction loadFromDataBank(key)\n    if not databank then\n        return {}\n    end\n    local data = {}\n    if not databank.hasKey(key) then\n        return data\n    end\n    data = databank.getStringValue(key)\n    if data == nil or string.len(data) == 0 then\n        return {}\n    end\n    data = data:gsub(\"\\'\", \"\\\"\")\n    data = data:gsub(\"\\\\\\\"\", \"\\\"\")\n\n    if string.sub(data, 1, 1) == \"\\\"\" then\n        data = string.sub(data, 2)\n    end\n    if string.sub(data, -1) == \"\\\"\" then\n        data = string.sub(data, 1, -2)\n    end\n\n    --system.print(\"Loading: \" .. data)\n    data = deserialize(data)\n    --system.print(\"Loaded! \")\n    if data == nil then\n        return {}\n    end\n    return data\nend\nfunction formatDistance(distance)\n    if not distance then\n        return \"\"\n    end\n    if distance < 1000 then\n        return mfloor(distance) .. \"m\"\n    end\n\n    if distance < 200 * 1000 then\n        return round(distance / 1000, 1) .. \"km\"\n    end\n    return round(distance / (200 * 1000), 1) .. \"su\"\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"10"},{"code":"---\n--- Created by Zrips.\n--- DateTime: 2022-12-18 12:51\n---\n---\n\nlinkedTo = {}\nlinkedMaster = true\nlastAlive = system.getArkTime()\n\nlastAliveSentTime = system.getArkTime()\n\nlocal rx = 2560\nlocal ry = 1440\n\nlocal transmitterData = {}\nlocal dataSynched = {}\n\nlocal sendReceiveData = {}\n\nfunction getSyncProgress()\n\n    if not sendReceiveData.mt then\n        return -1, -1\n    end\n\n    if not sendReceiveData.mc then\n        return 0, 0\n    end\n\n    local master = sendReceiveData.mc / sendReceiveData.mt\n    local slave = 0\n\n    if sendReceiveData.st and sendReceiveData.sc then\n        if sendReceiveData.st == 0 then\n            slave = 1\n        else\n            slave = sendReceiveData.sc / sendReceiveData.st\n        end\n    end\n\n    if master == 1 and slave == 1 then\n        return -1, -1\n    end\n\n    return master * 100, slave * 100\nend\n\nfunction syncInProgress ()\n    local v1, v2 = getSyncProgress()\n    return v1 >= 0 or v2 >= 0\nend\nfunction brakeLink()\n\n    if linkedTo.id then\n        local data = { brakeLink = construct.getId() }\n        local dataSyncPersonalChannel = (emitterChannel .. \"_\" .. linkedTo.id):gsub(\" \", \"_\")\n        transmitter.send(dataSyncPersonalChannel, serialize(data))\n    end\n\n    linkedTo = {}\n    linkedMaster = true\n    lastAlive = system.getArkTime()\n    minerInfo()\nend\n\nfunction getHandShakePacket(shake)\n\n    local data = {}\n    data.sync = PBstartTime\n    data.construct = construct.getName()\n    data.id = construct.getId()\n    data.location = ConvertLocalToWorld(unit)\n    data.playerName = player.getName()\n    data.shake = shake\n\n    return data\nend\n\nfunction checkAlive()\n    if not linkedTo.id then\n        return\n    end\n\n    if #transmitterData > 0 then\n        lastAlive = system.getArkTime()\n        return\n    end\n\n    if syncInProgress() then\n        lastAlive = system.getArkTime()\n        return\n    end\n\n    transmitterData = {}\n    sendReceiveData = {}\n\n    if lastAliveSentTime + 1 > system.getArkTime() then\n        return\n    end\n\n    if lastAlive + 3 < system.getArkTime() then\n        brakeLink()\n        return\n    end\n\n    lastAliveSentTime = system.getArkTime()\n\n    local data = getHandShakePacket(false)\n    data.alive = true\n    local dataSyncPersonalChannel = (emitterChannel .. \"_\" .. linkedTo.id):gsub(\" \", \"_\")\n    transmitter.send(dataSyncPersonalChannel, serialize(data))\nend\n\nfunction receiveAlive(data)\n    if not linkedTo.id or data.id ~= linkedTo.id then\n        return\n    end\n\n    if data.playerName ~= player.getName() then\n        return\n    end\n\n    lastAlive = system.getArkTime()\n    linkedTo = data\n\n    if data.sync < PBstartTime then\n        linkedMaster = false\n    end\n\nend\n\nfunction onDataSyncHandShake(data)\n    if miningPost then\n        return\n    end\n\n    if not transmitter then\n        return\n    end\n\n    if not data.sync then\n        return\n    end\n\n    if data.id == construct.getId() then\n        return\n    end\n\n    if data.playerName ~= player.getName() then\n        return\n    end\n\n    linkedTo = data\n\n    lastAlive = system.getArkTime()\n    lastAliveSentTime = system.getArkTime()\n\n    if data.sync < PBstartTime then\n        linkedMaster = false\n    else\n        startDataSync()\n    end\n\n    if not data.shake then\n        local dataSyncPersonalChannel = (emitterChannel .. \"_\" .. linkedTo.id):gsub(\" \", \"_\")\n        transmitter.send(dataSyncPersonalChannel, serialize(getHandShakePacket(true)))\n    end\nend\n\nlocal lastHandShake = 0\n\nfunction dataSyncHandShake()\n\n    if linkedTo.sync then\n        return\n    end\n\n    if miningPost then\n        return\n    end\n\n    if not transmitter then\n        return\n    end\n\n    if lastHandShake + 1 > system.getArkTime() then\n        return\n    end\n\n    lastHandShake = system.getArkTime()\n\n    transmitter.send(emitterChannel, serialize(getHandShakePacket(false)))\nend\n\nfunction getDataForSync(flowerName, patchName, loadedPatch, flowerTime)\n    local patchInfo = {}\n\n    patchInfo[1] = flowerName\n    patchInfo[2] = patchName\n    patchInfo[3] = loadedPatch.time\n\n    local tempMiners = {}\n\n    local prevOreId = 0\n    for id, miner in ipairs(loadedPatch.miners) do\n        data = {}\n        data[1] = miner.s -- state\n        data[2] = miner.r -- Rate\n        data[3] = miner.c -- calibration\n        data[4] = miner.o -- optimal\n        data[5] = miner.e -- efficiency\n        data[6] = miner.pid -- player ID\n        data[7] = miner.et -- extraction time\n        data[8] = miner.lv -- last Volume\n        data[9] = miner.l -- location\n        if prevOreId ~= miner.oid then\n            data[10] = miner.oid -- ore ID\n        end\n        prevOreId = miner.oid\n        tempMiners[#tempMiners + 1] = data\n    end\n\n    return {\n        dsync = #transmitterData + 1,\n        ft = flowerTime,\n        p = patchInfo,\n        m = tempMiners,\n        c = loadedPatch.c\n    }\nend\n\nfunction getDataForSyncCompacted(flowerName, patchName, loadedPatch, flowerTime)\n    local patchInfo = {}\n\n    patchInfo[1] = flowerName\n    patchInfo[2] = patchName\n    patchInfo[3] = compactPatchData(loadedPatch)\n\n    return {\n        #transmitterData + 1,\n        flowerTime,\n        patchInfo\n    }\nend\n\nfunction startDataSync()\n\n    if not linkedTo.sync then\n        return\n    end\n\n    dataSynched = {}\n    transmitterData = {}\n    sendReceiveData = {}\n\n    dataBankFlowers = loadFromDataBank(\"_Flowers_\")\n\n    --local shown = false\n\n    for flowerName, f in pairs(dataBankFlowers) do\n        for _, patchName in pairs(f.p) do\n            local loadedPatch = getPatchInformationFromDatabank(flowerName, patchName)\n            if loadedPatch then\n                transmitterData[#transmitterData + 1] = getDataForSync(flowerName, patchName, loadedPatch, f.time)\n            end\n        end\n    end\n\n    sendReceiveData.mt = #transmitterData\n\n    transmitterData[#transmitterData + 1] = { dsync = -1, p = {} }\n    \n    system.print(\"Data to be synched: \".. #transmitterData)\n\n    unit.setTimer(\"sync\", 0.11)\nend\n\nfunction startSlaveDataSync()\n\n    if linkedMaster then\n        sendReceiveData = {}\n        updateDataBankCache()\n        sendFlowersInformation()\n        return\n    end\n\n    lastAlive = system.getArkTime()\n\n    transmitterData = {}\n\n    dataBankFlowers = loadFromDataBank(\"_Flowers_\")\n\n    for flowerName, f in pairs(dataBankFlowers) do\n        for _, patchName in pairs(f.p) do\n\n            local fName = flowerName:gsub(\" \", \"_\")\n            local pName = patchName:gsub(\" \", \"_\")\n\n            if not table_contains(dataSynched, fName .. \"_\" .. pName) then\n                local loadedPatch = getPatchInformationFromDatabank(flowerName, patchName)\n                if loadedPatch then\n                    transmitterData[#transmitterData + 1] = getDataForSync(flowerName, patchName, loadedPatch, f.time)\n                end\n            end\n        end\n    end\n\n    for id, data in ipairs(transmitterData) do\n        data.t = #transmitterData\n    end\n\n    sendReceiveData.st = #transmitterData\n\n    transmitterData[#transmitterData + 1] = { dsync = -1, p = {} }\n\n    unit.setTimer(\"sync\", 0.11)\nend\n\nfunction dataSyncReceived(data)\n\n    if not data.dsync then\n        return\n    end\n\n    lastAlive = system.getArkTime()\n    lastAliveSentTime = system.getArkTime()\n\n    if data.dsync < 0 then\n        startSlaveDataSync()\n        return\n    end\n\n    dataBankFlowers = loadFromDataBank(\"_Flowers_\")\n\n    sendReceiveData.sc = data.dsync\n    sendReceiveData.st = data.t\n\n    local patchInfo = data.p\n    local minerInfo = data.m\n\n    local flowerName = patchInfo[1]:gsub(\" \", \"_\")\n    local patchName = patchInfo[2]:gsub(\" \", \"_\")\n\n    local keyName = flowerName .. \"_\" .. patchName\n\n    local flower = dataBankFlowers[flowerName]\n\n    if not flower then\n        flower = {}\n        flower.p = {}\n    end\n\n    flower.time = data.ft\n\n    local contains = table_contains(flower.p, patchName)\n\n    local newRecord = true\n\n    if not contains then\n        flower.p[#flower.p + 1] = patchName\n    else\n        newRecord = false\n    end\n\n    if acceptNewRecords or not newRecord then\n        dataBankFlowers[flowerName] = flower\n        saveToDataBank(\"_Flowers_\", dataBankFlowers)\n    end\n\n    local patch = getPatchInformationFromDatabank(flowerName, patchName)\n\n    if patch.time and patch.time < patchInfo[3] or not patch.time then\n\n        if not patch.time then\n            newRecord = true\n        else\n            newRecord = false\n        end\n\n        patch.time = patchInfo[3]\n        patch.miners = {}\n\n        local previousOre = 0\n        for id, data in ipairs(minerInfo) do\n            miner = {}\n            miner.s = data[1]  -- state\n            miner.r = data[2]  -- Rate\n            miner.c = data[3]  -- calibration\n            miner.o = data[4]  -- optimal\n            miner.e = data[5]  -- efficiency\n            miner.pid = data[6] -- player ID\n            miner.et = data[7]   -- extraction time\n            miner.lv = data[8]  -- last Volume\n            miner.l = data[9]  -- location\n\n            if data[10] then\n                previousOre = data[10]\n            end\n            miner.oid = previousOre  -- ore ID\n            patch.miners[#patch.miners + 1] = miner\n        end\n\n        patch.c = data.c\n\n        if acceptNewRecords or not newRecord then\n            saveToDataBank(keyName, compactPatchData(patch))\n            dataBankPatches[keyName] = patch\n        end\n    end\n\n    if patch.time and patch.time <= patchInfo[3] or not patch.time then\n        if not table_contains(dataSynched, keyName) then\n            dataSynched[#dataSynched + 1] = keyName\n        end\n    end\n\n    local temp = {\n        dsync = data.dsync\n    }\n    local dataSyncPersonalChannel = (emitterChannel .. \"_\" .. linkedTo.id):gsub(\" \", \"_\")\n    transmitter.send(dataSyncPersonalChannel, serialize(temp))\nend\n\nlocal sendingData = 1\n\nfunction dataReceiveHandShake(data)\n    if not data.dsync then\n        return\n    end\n    sendingData = data.dsync + 1\n    dataSync()\nend\n\nfunction dataSync()\n\n    if not linkedTo.sync then\n        return\n    end\n\n    if sendingData > #transmitterData then\n        transmitterData = {}\n        sendingData = 1\n        return\n    end\n\n    if #transmitterData == 0 then\n        sendingData = 1\n        return\n    end\n\n    local data = transmitterData[sendingData]\n\n    sendReceiveData.mc = sendingData\n\n    local dataSyncPersonalChannel = (emitterChannel .. \"_\" .. linkedTo.id):gsub(\" \", \"_\")\n\n    lastAlive = system.getArkTime()\n\n    transmitter.send(dataSyncPersonalChannel, serialize(data))\n\n    unit.stopTimer(\"sync\")\nend\n\nlocal range = 150\n\nfunction generateLinkSVG()\n    if not linkedTo.sync then\n        return \"\"\n    end\n\n    local svg = \"\"\n\n    local tpos1 = library.getPointOnScreen(linkedTo.location)\n    local tpos2 = library.getPointOnScreen(ConvertLocalToWorld(unit))\n\n    local pos1 = {\n        x = tpos1[1] * 100,\n        y = tpos1[2] * 100 }\n\n    local pos2 = {\n        x = tpos2[1] * 100,\n        y = tpos2[2] * 100 }\n\n    local pos1Text = \"M\"\n    local pos2Text = \"S\"\n\n    if linkedMaster then\n        pos2Text = \"M\"\n        pos1Text = \"S\"\n    end\n\n    if pos1.x ~= 0 and pos1.y ~= 0 and pos1.x > -range and pos1.x < 100 + range and pos1.y > -range and pos1.y < 100 + range and pos2.x > -range and pos2.x < 100 + range and pos2.y > -range and pos2.y < 100 + range and pos2.x ~= 0 and pos2.y ~= 0 then\n        svg = svg .. [[\n        <svg width='100%' height='100%' style='position:absolute;top:0%;left:0%' viewbox='0 0 ]] .. rx .. [[ ]] .. ry .. [[' preserveAspectRatio=\"none\" transform-box=\"fill-box\" xmlns=\"http://www.w3.org/2000/svg\">\n        <g opacity=\"0.7\"><line x1=\"]] .. pos1.x .. [[%\" y1=\"]] .. pos1.y .. [[%\" x2=\"]] .. pos2.x .. [[%\" y2=\"]] .. pos2.y .. [[%\" stroke=\"#87ceff\" stroke-dasharray=\"10 10\" /></g></svg>]]\n    end\n\n    if pos1.x > 0 and pos1.x < 100 and pos1.y > 0 and pos1.y < 100 then\n        svg = svg .. generateTextBlock(pos1.x, pos1.y, getOpacityByEdge(pos1.x / 100, pos1.y / 100, 0.7), pos1Text, 1)\n    end\n\n    if pos2.x > 0 and pos2.x < 100 and pos2.y > 0 and pos2.y < 100 then\n        svg = svg .. generateTextBlock(pos2.x, pos2.y, getOpacityByEdge(pos2.x / 100, pos2.y / 100, 0.7), pos2Text, 1)\n    end\n\n    inScreeen = true\n    return svg\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"11"},{"code":"function getScreenScript()\n    return [[\n---\n--- Created by Zrips.\n--- DateTime: 2022-10-13 11:30\n---\n\n\nbigFont = loadFont('Play-Bold', 25)\nfont = loadFont('Play', 20)\nsmallFont = loadFont('Play', 15)\n\nimages = {}\n\nlocal cPressed = getCursorPressed()\nlocal cReleased = getCursorReleased()\nlocal cX, cY = getCursor()\n\nlocal input = getInput();\nlocal layer = createLayer()\n\nif not init then\n\n    init = true\n\n    rx, ry = getResolution()\n\n    PBAlive = false\n    \n    minimalCalibration = ]]..minimalCalibration..[[\n    allowEdit = ]]..tostring(allowEdit)..[[\n    allowDelete = ]]..tostring(allowDelete)..[[\n    acceptNewRecords = ]]..tostring(acceptNewRecords)..[[\n    \n    flowersCollumns = 5\n    flowersLines = 3\n\n    flowerWidth = 100\n    flowerHeight = 100\n    flowerHexSize = 100\n    flowerBoxSize = 180\n    flowerBoxCorner = 40\n\n    patchesCircleSize = 175\n\n    lineSideGap = 10\n    lineHeight = 60\n    lineWidth = rx - (lineSideGap * 2)\n    lineSpacing = 20\n    lineIconSize = lineHeight - 10\n\n    lastUpdate = getTime()\n    lastDataUpdate = getTime()\n\n    currentTime = 0\n\n    destinationIconSize = 50\n\n    lockIconSize = 40\n\n    containerBarWidth = 750\n    containerBarHeight = 30\n\n    editor = {}\n\n    mfloor = math.floor\n    mceil = math.ceil\n    mrandom = math.random\n    mabs = math.abs\n    msin = math.sin\n    mcos = math.cos\n    mmin = math.min\n    mpi = math.pi\n    mrad = math.rad\n\n    color = \"#660044\"\n\n    yellowColor = { r = 250 / 255, g = 212 / 255, b = 122 / 255 }\n    cyanColor = { r = 135 / 255, g = 206 / 255, b = 235 / 255 }\n    uiSettings = { r = 37 / 255, g = 57 / 255, b = 64 / 255 }\n    barColor1 = { r = 255 / 255, g = 255 / 255, b = 255 / 255 }\n    orangeColor = { r = 224 / 255, g = 165 / 255, b = 85 / 255 }\n    redColor = { r = 177 / 255, g = 80 / 255, b = 0 / 255 }\n    greenColor = { r = 4 / 255, g = 159 / 255, b = 0 / 255 }\n\n    backgroundColor = { r = 13 / 255, g = 24 / 255, b = 28 / 255 }\n\n    barColorGood = { r = 4 / 255, g = 159 / 255, b = 0 / 255 }\n    barColorBad = { r = 177 / 255, g = 80 / 255, b = 0 / 255 }\n\n    barStartY = 50\n\n    barHeight = 80\n    barWidth = 130\n    barSpacing = 4\n\n    barInset = 2\n\n    sectionSpacing = 20\n\n    middleGap = 2\n    textBarSpacing = 10\n    flowers = {}\n    flower = {}\n    patch = {}\n    container = nil\n\n    closestFlower = {}\n\n    deleteAction = {}\n\n    menuNumber = 1\n\n    prevInput = input\n\n    function getArkTime()\n        return currentTime + getTime()\n    end\n\n    function mixColors(color1, color2, percent)\n        local inverse_percent = 1 - percent\n        local redPart = color2.r * percent + color1.r * inverse_percent\n        local greenPart = color2.g * percent + color1.g * inverse_percent\n        local bluePart = color2.b * percent + color1.b * inverse_percent\n        return { r = redPart, g = greenPart, b = bluePart };\n    end\n\n    function round(number, decimals)\n        local power = 10 ^ decimals\n        return mceil(number * power) / power\n    end\n\n    local concat = table.concat\n    local function internalSerialize(table, tC, t)\n        t[tC] = \"{\"\n        tC = tC + 1\n        if #table == 0 then\n            local hasValue = false\n            for key, value in pairs(table) do\n                hasValue = true\n                local keyType = type(key)\n                if keyType == \"string\" then\n                    t[tC] = key .. \"=\"\n                elseif keyType == \"number\" then\n                    t[tC] = \"[\" .. key .. \"]=\"\n                elseif keyType == \"boolean\" then\n                    t[tC] = \"[\" .. tostring(key) .. \"]=\"\n                else\n                    t[tC] = \"notsupported=\"\n                end\n                tC = tC + 1\n\n                local check = type(value)\n                if check == \"table\" then\n                    tC = internalSerialize(value, tC, t)\n                elseif check == \"string\" then\n                    t[tC] = '\"' .. value .. '\"'\n                elseif check == \"number\" then\n                    t[tC] = value\n                elseif check == \"boolean\" then\n                    t[tC] = tostring(value)\n                else\n                    t[tC] = '\"Not Supported\"'\n                end\n                t[tC + 1] = \",\"\n                tC = tC + 2\n            end\n            if hasValue then\n                tC = tC - 1\n            end\n        else\n            for i = 1, #table do\n                local value = table[i]\n                local check = type(value)\n                if check == \"table\" then\n                    tC = internalSerialize(value, tC, t)\n                elseif check == \"string\" then\n                    t[tC] = '\"' .. value .. '\"'\n                elseif check == \"number\" then\n                    t[tC] = value\n                elseif check == \"boolean\" then\n                    t[tC] = tostring(value)\n                else\n                    t[tC] = '\"Not Supported\"'\n                end\n                t[tC + 1] = \",\"\n                tC = tC + 2\n            end\n            tC = tC - 1\n        end\n        t[tC] = \"}\"\n        return tC\n    end\n\n    function sendFlowerRequest(flowerName)\n        local out = {}\n        out.type = \"flower\"\n        out.flowerName = flowerName\n        out.t = math.random(0, 10000)\n        setOutput(serialize(out))\n\n        flower = {}\n    end\n\n    function sendFlowersRequest()\n        local out = {}\n        out.type = \"flowers\"\n        out.t = math.random(0, 10000)\n        setOutput(serialize(out))\n    end\n\n    function serialize(value)\n        local t = {}\n        local check = type(value)\n\n        if check == \"table\" then\n            internalSerialize(value, 1, t)\n        elseif check == \"string\" then\n            return '\"' .. value .. '\"'\n        elseif check == \"number\" then\n            return value\n        elseif check == \"boolean\" then\n            return tostring(value)\n        else\n            return '\"Not Supported\"'\n        end\n\n        return concat(t)\n    end\n\n    function deserialize(s)\n        return load(\"return \" .. s)()\n    end\n\n    function secondsToClockString(time, skipSeconds)\n        if time == nil or time <= 0 then\n            return \"-\"\n        else\n            local days = mfloor(time / 86400)\n            local hours = mfloor((time % 86400) / 3600)\n            local minutes = mfloor((time % 3600) / 60)\n            local seconds = mfloor(time % 60)\n            str = \"\"\n            if days > 0 then\n                str = str .. days .. \"d \"\n            end\n            if hours > 0 then\n                str = str .. hours .. \"h \"\n            end\n            if minutes > 0 then\n                str = str .. minutes .. \"m \"\n            end\n            if not skipSeconds and seconds > 0 or string.len(str) == 0 then\n                str = str .. seconds .. \"s\"\n            end\n            return str\n        end\n    end\n\n    function formatDistance(distance)\n        if not distance then\n            return \"-\"\n        end\n        if distance < 1000 then\n            return mfloor(distance) .. \"m\"\n        end\n\n        if distance < 200 * 1000 then\n            return round(distance / 1000, 2) .. \"km\"\n        end\n        return round(distance / (200 * 1000), 2) .. \"su\"\n    end\n\n    function calibrationRequiredTime(calibration, optimal)\n        return ((calibration - optimal) / 0.625) * 3600\n    end\n\n    function timeUntilReCalibration(calibration, extractionTime, lastUpdate, optimal)\n        local fe = getArkTime() - lastUpdate + extractionTime\n\n        local cal = calibrationRequiredTime(calibration, optimal)\n        if fe > 259200 then\n            return cal\n        end\n\n        if fe < 86400 and cal + (259200 - fe) < 86400 or cal < 0 then\n            return 86400 - fe\n        end\n\n        return cal + (259200 - fe)\n    end\n\n    function estimateCalibration(calibration, extractionTime, lastUpdate, noRound)\n\n        local fromExtraction = getArkTime() - lastUpdate + extractionTime\n\n        if fromExtraction <= 259200 then\n            return calibration\n        end\n\n        local timeWhileDropping = fromExtraction - 259200\n\n        if getArkTime() - lastUpdate < timeWhileDropping then\n            timeWhileDropping = getArkTime() - lastUpdate\n        end\n\n        local lostPercent = 0.625 * (timeWhileDropping / 3600)\n\n        calibration = calibration - lostPercent\n        if not noRound then\n            calibration = round(calibration, 2)\n        end\n\n        if calibration < 0 then\n            calibration = 0\n        end\n        return calibration\n    end\n\n    function getOreImage(id, icon)\n\n        if images[id] == nil or not isImageLoaded(images[id]) then\n            images[id] = loadImage(\"resources_generated/env/\" .. icon)\n        end\n\n        local image = images[id]\n        if image and image ~= nil then\n            return image\n        end\n\n        image = loadImage(\"resources_generated/env/\" .. icon)\n\n        images[id] = image\n        return image\n    end\n\n    sendFlowersRequest()\n\n\nend\n\nfunction addTextCombined(layer, font, text, x, y, c, ca, ah, av)\n    if c then\n        if ca == nil then\n            ca = 1\n        end\n        setNextFillColor(layer, c.r, c.g, c.b, ca)\n    end\n    if ah == nil then\n        ah = AlignH_Center\n    end\n    if av == nil then\n        av = AlignV_Middle\n    end\n    setNextTextAlign(layer, ah, av)\n    addText(layer, font, tostring(text), x, y)\nend\n\nfunction set(layer, fc, fa, sc, sa, sw)\n    if fc == nil then\n        setNextFillColor(layer, 0, 0, 0, 0)\n    else\n        setNextFillColor(layer, fc.r, fc.g, fc.b, fa)\n    end\n\n    if sc == nil then\n        setNextStrokeColor(layer, 0, 0, 0, 0)\n        setNextStrokeWidth(layer, 0)\n    else\n        setNextStrokeColor(layer, sc.r, sc.g, sc.b, sa)\n        setNextStrokeWidth(layer, sw)\n    end\nend\n\nfunction drawLock(layer, x, y)\n\n    set(layer, nil, 0, yellowColor, 0.5, 0.1)\n    addBox(layer, x, y, lockIconSize, lockIconSize)\n\n    local edgeGap = 5\n\n    local circleGap = 10\n\n    set(layer, cyanColor, 0.8, cyanColor, 0.8, 0.1)\n    addCircle(layer, x + (lockIconSize / 2), y + (lockIconSize / 2) - (circleGap - edgeGap), (lockIconSize / 2) - circleGap)\n\n    set(layer, cyanColor, 0.8, cyanColor, 0.8, 0.1)\n    addBox(layer, x + circleGap, y + (lockIconSize / 2) - edgeGap, (lockIconSize - (circleGap * 2)), (lockIconSize / 2) - edgeGap)\n\n    set(layer, backgroundColor, 1, backgroundColor, 0.8, 0.1)\n    addCircle(layer, x + (lockIconSize / 2), y + (lockIconSize / 2) - (circleGap - edgeGap), (lockIconSize / 2) - circleGap - (circleGap / 2))\n\n    local topL = createLayer()\n    set(topL, cyanColor, 0.8, cyanColor, 0.8, 0.1)\n    addBox(topL, x + edgeGap, y + (lockIconSize / 2), (lockIconSize - (edgeGap * 2)), (lockIconSize / 2) - edgeGap)\nend\n\nfunction createBox(upLayer, mainColor, backgroundColor, x, y, width, height)\n    set(upLayer, mainColor, 1, backgroundColor, 1, 2)\n    addBox(upLayer, x, y, width, height)\nend\n\nfunction createDestinationIcon(x, y, width, height)\n\n    local mainColor = cyanColor\n\n    if insideArea(x, y, width, height) and not deleteAction.fn then\n        mainColor = orangeColor\n        if cReleased then\n            local out = {}\n            out.type = \"location\"\n            if menuNumber == 3 then\n                out.patch = patch.name\n            end\n            out.fn = flower.name\n            setOutput(serialize(out))\n            mainColor = uiSettings\n        end\n    end\n\n    set(layer, backgroundColor, 1, mainColor, 1, 2)\n    addCircle(layer, x + (width / 2), y + (height / 2), width / 2 - 5)\n\n    local boxWidth = width * 0.1\n    local boxHeight = (height / 2) * 0.7\n\n    local upLayer = createLayer()\n\n    createBox(upLayer, mainColor, backgroundColor, x + (width / 2) - (boxWidth / 2), y, boxWidth, boxHeight)\n    createBox(upLayer, mainColor, backgroundColor, x + (width / 2) - (boxWidth / 2), y + height - boxHeight, boxWidth, boxHeight)\n    createBox(upLayer, mainColor, backgroundColor, x, y + (height / 2) - (boxWidth / 2), boxHeight, boxWidth)\n    createBox(upLayer, mainColor, backgroundColor, x + width - boxHeight, y + (height / 2) - (boxWidth / 2), boxHeight, boxWidth)\nend\n\nfunction createEditIcon(x, y, width, height)\n\n    if not allowEdit then\n        return\n    end\n\n    local mainColor = cyanColor\n    if insideArea(x, y, width, height) then\n        mainColor = orangeColor\n        if cReleased then\n            if editor.edit then\n                editor = {}\n            else\n                editor.edit = true\n            end\n        end\n    end\n    setNextFillColor(layer, mainColor.r, mainColor.g, mainColor.b, 1)\n    drawQuickImage(\"resources_generated/iconsLib/misclib/miningtool.png\", x + (width / 2.2), y + (width / 2.2), width)\nend\n\nfunction createLine(x1, y1, x2, y2, strokeWidth, strokeColor)\n    set(layer, strokeColor, 1, strokeColor, 1, strokeWidth)\n    addLine(layer, x1, y1, x2, y2)\nend\n\nfunction createDeleteIcon(x, y, width, height, minerID)\n\n    if not allowDelete then\n        return\n    end\n\n    local mainColor = cyanColor\n\n    if insideArea(x, y, width, height) and not deleteAction.fn then\n        mainColor = barColorBad\n        if cReleased then\n            local out = {}\n            out.type = \"delete\"\n            if menuNumber == 3 then\n                out.patch = patch.name\n            end\n            out.fn = flower.name\n            out.miner = minerID\n            deleteAction = out\n            mainColor = uiSettings\n        end\n    end\n\n    local spacing = 10\n\n    set(layer, backgroundColor, 1, mainColor, 1, 2)\n    addBoxRounded(layer, x, y, width, height, 3)\n\n    createLine(x + spacing, y + spacing, x + width - spacing, y + height - spacing, 4, mainColor)\n    createLine(x + spacing, y + height - spacing, x + width - spacing, y + spacing, 4, mainColor)\nend\n\nfunction drawAliveOverlay()\n    if PBAlive then\n        return\n    end\n\n    local AliveLayer = createLayer()\n\n    setNextFillColor(AliveLayer, backgroundColor.r, backgroundColor.g, backgroundColor.b, 0.95)\n    setNextStrokeWidth(AliveLayer, 0)\n    addBox(AliveLayer, 0, 0, rx, ry)\n\n    addTextCombined(AliveLayer, bigFont, \"Waiting for Programmable Board to be turned ON\", rx / 2, ry / 2, cyanColor)\n\n    if lastUpdate + 1 < getTime() then\n        sendFlowersRequest()\n        lastUpdate = getTime()\n    end\nend\n\nfunction drawDeleteConfirmation()\n    if not deleteAction.fn then\n        return\n    end\n\n    local deleteLayer = createLayer()\n\n    setNextFillColor(deleteLayer, backgroundColor.r, backgroundColor.g, backgroundColor.b, 0.95)\n    setNextStrokeWidth(deleteLayer, 0)\n    addBox(deleteLayer, 0, 0, rx, ry)\n\n    local buttonWidth = 250\n    local buttonHeight = 50\n    local buttonGap = 10\n\n    local yesHoverColor = backgroundColor\n\n    if insideArea(rx / 2 - buttonGap - buttonWidth, ry / 2 + buttonGap, buttonWidth, buttonHeight) and deleteAction.fn then\n        yesHoverColor = orangeColor\n        if cReleased then\n            setOutput(serialize(deleteAction))\n            deleteAction = {}\n            menuNumber = menuNumber - 1\n            return\n        end\n    end\n\n    set(deleteLayer, yesHoverColor, 1, cyanColor, 1, 1)\n    addBox(deleteLayer, rx / 2 - buttonGap - buttonWidth, ry / 2 + buttonGap, buttonWidth, buttonHeight)\n\n    addTextCombined(deleteLayer, bigFont, \"YES\", rx / 2 - buttonGap - (buttonWidth / 2), ry / 2 + buttonGap + (buttonHeight / 2), uiSettings)\n\n    local noHoverColor = backgroundColor\n    local noHoverColor2 = cyanColor\n    if insideArea(rx / 2 + buttonGap, ry / 2 + buttonGap, buttonWidth, buttonHeight) and deleteAction.fn then\n        noHoverColor = cyanColor\n        noHoverColor2 = backgroundColor\n        if cReleased then\n            deleteAction = {}\n            return\n        end\n    end\n\n    set(deleteLayer, noHoverColor, 1, cyanColor, 1, 1)\n    addBox(deleteLayer, rx / 2 + buttonGap, ry / 2 + buttonGap, buttonWidth, buttonHeight)\n\n    addTextCombined(deleteLayer, bigFont, \"NO\", rx / 2 + buttonGap + (buttonWidth / 2), ry / 2 + buttonGap + (buttonHeight / 2), noHoverColor2)\n\n    local deleteText = \"Delete\"\n\n    if deleteAction.patch then\n        deleteText = \"Delete \" .. deleteAction.fn .. \" flowers \" .. deleteAction.patch .. \" mining site?\"\n    else\n        deleteText = \"Delete \" .. deleteAction.fn .. \" flower?\"\n    end\n\n    addTextCombined(deleteLayer, bigFont, deleteText, rx / 2, ry / 2 - buttonGap * 2, cyanColor)\nend\n\nfunction recalculateColumnsAndLines()\n    local number = #flowers\n    if number < 5 then\n        flowersCollumns = number\n    else\n        flowersCollumns = 5\n    end\n    flowersLines = mceil(number / 5)\nend\n\nfunction requestClosest()\n    setOutput(serialize({ type = \"closest\" }))\nend\n\nif input ~= prevInput then\n    PBAlive = true\n    local params = deserialize(input) or {}\n    if params.type == \"shutdown\" then\n        PBAlive = false\n    elseif params.type == \"closest\" then\n        closestFlower.flower = params.flower\n        closestFlower.patch = params.patch\n        closestFlower.distance = params.distance\n        setOutput(\"\")\n    elseif params.type == \"miners\" then\n        patch.miners = params.miners\n        patch.time = params.t\n        patch.ores = params.ores\n        currentTime = params.t - getTime()\n        lastDataUpdate = getTime()\n        menuNumber = 3\n    elseif params.type == \"container\" then\n        container = params\n    elseif params.type == \"flowers\" then\n        menuNumber = 1\n        flowers = params.f\n        requestClosest()\n        recalculateColumnsAndLines()\n    elseif params.type == \"flower\" then\n        flower = params.flower\n        currentTime = params.t - getTime()\n        menuNumber = 2\n        requestClosest()\n    elseif params.type == \"patch\" then\n        patch = {}\n        patch.miners = params.miners\n        patch.time = params.time\n        patch.name = params.name\n        patch.ores = params.ores\n        if params.c then\n            container = {\n                mass = params.c[1],\n                maxVol = params.c[2],\n                vol = params.c[3],\n            }\n        end\n        menuNumber = 3\n        currentTime = params.t - getTime()\n        setOutput(\"\")\n    end\n    prevInput = input\nend\n\nfunction drawQuickImage (url, x, y, size)\n    local posX = x - (size / 2)\n    local posY = y - (size / 2)\n    image = loadImage(url)\n    addImage(layer, image, posX, posY, size, size)\nend\n\nsetBackgroundColor(backgroundColor.r, backgroundColor.g, backgroundColor.b)\n\nfunction regular_polygon(centerX, centerY, polygon_sides, polygon_radius, polygon_rotation)\n    local regular_polygon = {}\n    polygon_rotation = polygon_rotation or 0\n    polygon_rotation = mrad(-(polygon_rotation % 360))\n    polygon_angle = (mpi * 2) / polygon_sides\n    polygon_rotation = polygon_rotation + (polygon_angle / 2)\n    for i = 0, polygon_sides, 1 do\n        angle = polygon_angle * i\n        angle = angle + polygon_rotation\n        x = msin(angle) * polygon_radius\n        y = mcos(angle) * polygon_radius\n        x = x + centerX\n        y = y + centerY\n        regular_polygon[#regular_polygon + 1] = { x, y }\n    end\n    return regular_polygon\nend\n\nfunction insideArea(x, y, width, height)\n    return cX > x and cX < x + width and cY > y and cY < y + height\nend\n\nfunction insideHex(x, y)\n    return cX > x - (flowerHexSize / 1.2) and cX < x + (flowerHexSize / 1.2) and cY > y - (flowerHexSize / 1.2) and cY < y + (flowerHexSize / 1.2)\nend\n\nfunction drawHex(x, y, flowerHexSize, stroke)\n    local strokeWidth = 1\n    if stroke then\n        strokeWidth = stroke\n    end\n    local poly = regular_polygon(x, y, 6, flowerHexSize, rotation)\n    local prevPoint = poly[#poly]\n    for key, point in pairs(poly) do\n        if insideHex(x, y) then\n            setNextStrokeColor(layer, yellowColor.r, yellowColor.g, yellowColor.b, strokeWidth)\n        else\n            setNextStrokeColor(layer, cyanColor.r, cyanColor.g, cyanColor.b, strokeWidth)\n        end\n        addLine(layer, prevPoint[1], prevPoint[2], point[1], point[2])\n        prevPoint = point\n    end\nend\n\nfunction drawCornedBox(x, y, flowerBoxSize, stroke, corner)\n    local strokeWidth = 1\n    if stroke then\n        strokeWidth = stroke\n    end\n\n    local originX = x - (flowerBoxSize / 2)\n    local originY = y - (flowerBoxSize / 2)\n\n    if insideArea(originX, originY, flowerBoxSize, flowerBoxSize) then\n        setDefaultStrokeColor(layer, Shape_Line, yellowColor.r, yellowColor.g, yellowColor.b, 1)\n    else\n        setDefaultStrokeColor(layer, Shape_Line, cyanColor.r, cyanColor.g, cyanColor.b, 1)\n    end\n\n    setDefaultStrokeWidth(layer, Shape_Line, stroke)\n\n    addLine(layer, originX, originY, originX + flowerBoxSize - corner, originY)\n    addLine(layer, originX + flowerBoxSize - corner, originY, originX + flowerBoxSize, originY + corner)\n    addLine(layer, originX + flowerBoxSize, originY + corner, originX + flowerBoxSize, originY + flowerBoxSize)\n\n    local gap = 30\n\n    if insideArea(originX, originY, flowerBoxSize, flowerBoxSize) then\n        setDefaultStrokeColor(layer, Shape_Line, yellowColor.r, yellowColor.g, yellowColor.b, 0.5)\n    else\n        setDefaultStrokeColor(layer, Shape_Line, cyanColor.r, cyanColor.g, cyanColor.b, 0.1)\n    end\n\n    addLine(layer, originX, originY + gap, originX, originY + flowerBoxSize - corner - 1)\n    addLine(layer, originX, originY + flowerBoxSize - corner, originX + corner, originY + flowerBoxSize)\n    addLine(layer, originX + corner + 1, originY + flowerBoxSize, originX + flowerBoxSize - gap, originY + flowerBoxSize)\n\nend\n\nfunction getLowestInformation(lowest)\n    local colorLowest = cyanColor\n    local nextCalTime = lowest[2] - mfloor(getTime() - lastDataUpdate)\n    local calibText = secondsToClockString(nextCalTime, true)\n    if nextCalTime < 0 or lowest[1] < minimalCalibration and lowest[3] > 259200 then\n        colorLowest = redColor\n        calibText = \"Calibrate!\"\n    elseif lowest[1] < minimalCalibration and lowest[3] > 86400 or lowest[1] > 259200 then\n        colorLowest = orangeColor\n    end\n\n    if nextCalTime > 0 and nextCalTime < 86400 then\n        colorLowest = orangeColor\n    end\n\n    return colorLowest, calibText\nend\n\npreviousPlanet = nil\n\nfunction drawFlower(flower, x, y)\n\n    drawCornedBox(x, y, flowerBoxSize, 1, flowerBoxCorner)\n\n    local ly = y - (flowerHexSize / 2) - 20\n\n    addTextCombined(layer, font, flower[3], x, ly, cyanColor, 0.3)\n\n    addTextCombined(layer, font, flower[1][1]:gsub(\"_\", \" \"), x, y - 30, cyanColor, 0.7)\n\n    if flower[4] and flower[4][2] then\n        local colorLowest, calibText = getLowestInformation(flower[4])\n        addTextCombined(layer, font, round(flower[4][1], 2) .. \"%\", x, y + 20, colorLowest)\n        addTextCombined(layer, font, calibText, x, y, colorLowest)\n    end\n\n    if flower[5] then\n        showSmallContainerBarCentered(x, y + 35, flower[5][1])\n        addTextCombined(layer, smallFont, flower[5][2] .. \"T  \" .. flower[5][3] .. \"KL\", x, y + 55, cyanColor, 0.3)\n    end\n\n    addTextCombined(layer, smallFont, formatDistance(flower[2]), x, y + 70, cyanColor, 0.3)\n\n    if previousPlanet or flower[1][2] then\n        addTextCombined(layer, font, flower[1][2] or previousPlanet, x, ly + 20, cyanColor, 0.3)\n        if flower[1][2] then\n            previousPlanet = flower[1][2]\n        end\n    end\n\n    if closestFlower.flower and flower[1][1] == closestFlower.flower and closestFlower.distance < 5000 then\n        drawCornedBox(x, y, flowerBoxSize * 0.95, 0.5, flowerBoxCorner * 0.95)\n    end\n\n    if cReleased and insideHex(x, y) and not deleteAction.fn then\n        menuNumber = menuNumber + 1\n        sendFlowerRequest(flower[1][1])\n    end\nend\n\nfunction showFlowers()\n\n    rotation = 0\n\n    local column = 1\n    local line = 1\n\n    local secX = rx / (flowersCollumns)\n    local secY = (ry - 50) / (flowersLines)\n\n    for pos, flower in ipairs(flowers) do\n\n        local lx = (secX * column) - (secX / 2)\n        local ly = (secY * line) - (secY / 2) + 25\n\n        drawFlower(flower, lx, ly)\n\n        column = column + 1\n        if column > flowersCollumns then\n            column = 1\n            line = line + 1\n        end\n    end\n\n    if not acceptNewRecords then\n        drawLock(layer, rx - lockIconSize - 15, ry - lockIconSize - 15)\n    end\n\nend\n\nfunction drawBackButton(x, y, width, height)\n\n    if insideArea(x, y, width, height) and not deleteAction.fn then\n        setNextStrokeColor(layer, backgroundColor.r, backgroundColor.g, backgroundColor.b, 1)\n        setNextFillColor(layer, yellowColor.r, yellowColor.g, yellowColor.b, 1)\n        if cReleased then\n            menuNumber = menuNumber - 1\n\n            if #flowers == 0 or menuNumber == 1 then\n                sendFlowersRequest()\n            end\n\n            if menuNumber == 2 and flower.name then\n                sendFlowerRequest(flower.name)\n            end\n\n        end\n    else\n        setNextFillColor(layer, uiSettings.r, uiSettings.g, uiSettings.b, 1)\n        setNextStrokeColor(layer, cyanColor.r, cyanColor.g, cyanColor.b, 1)\n    end\n    setNextStrokeWidth(layer, 0.1)\n    addBox(layer, x, y, width, height)\n\n    if insideArea(x, y, width, height) then\n        addTextCombined(layer, font, \"Back\", x + (width / 2), y + (height / 2), backgroundColor)\n    else\n        addTextCombined(layer, font, \"Back\", x + (width / 2), y + (height / 2), barColor1, 0.5)\n    end\nend\n\nfunction showFlowerMenu()\n\n    rotation = 30\n    editor.sliders = {}\n    local lrx = rx\n    local lry = ry\n\n    local count = 0\n    local poly = {}\n\n    if flower.patches then\n        for pos, lPatch in ipairs(flower.patches) do\n            count = count + 1\n        end\n        if count == 1 or count > 3 then\n            poly[#poly + 1] = { rx / 2, ry / 2 }\n        elseif count == 2 then\n            poly[#poly + 1] = { rx / 2 - (patchesCircleSize / 2), ry / 2 }\n            poly[#poly + 1] = { rx / 2 + (patchesCircleSize / 2), ry / 2 }\n        elseif count == 3 then\n            poly[#poly + 1] = { rx / 2 - (patchesCircleSize / 2), ry / 2 + (patchesCircleSize / 2) }\n            poly[#poly + 1] = { rx / 2 + (patchesCircleSize / 2), ry / 2 + (patchesCircleSize / 2) }\n            poly[#poly + 1] = { rx / 2, ry / 2 - (patchesCircleSize / 2.75) }\n        end\n    end\n\n    local Tpoly = regular_polygon(lrx / 2, lry / 2, 6, patchesCircleSize, -120)\n\n    for pos, p in ipairs(Tpoly) do\n        if pos < 7 then\n            poly[#poly + 1] = p\n        end\n    end\n\n    if count > 7 then\n        poly[#poly + 1] = { poly[5][1] - patchesCircleSize, poly[5][2] }\n        poly[#poly + 1] = { poly[2][1] + patchesCircleSize, poly[2][2] }\n        poly[#poly + 1] = { poly[6][1] + patchesCircleSize, poly[6][2] }\n        poly[#poly + 1] = { poly[3][1] - patchesCircleSize, poly[3][2] }\n        poly[#poly + 1] = { poly[4][1] - patchesCircleSize, poly[4][2] }\n        poly[#poly + 1] = { poly[7][1] + patchesCircleSize, poly[7][2] }\n    end\n\n    local layer = createLayer()\n\n    if flower.patches then\n\n        for pos, lPatch in ipairs(flower.patches) do\n            local lx = poly[pos][1]\n            local ly = poly[pos][2]\n\n            drawHex(lx, ly, flowerHexSize)\n\n            addTextCombined(layer, font, lPatch[1], lx, ly - 50, cyanColor, 0.3)\n\n            if lPatch[6] then\n                showSmallContainerBarCentered(lx, ly - 23, lPatch[6])\n            end\n\n            if lPatch[4] and lPatch[4][2] then\n                addTextCombined(layer, font, round(lPatch[4][1], 2) .. \"%\", lx, ly, colorLowest)\n                local colorLowest, calibText = getLowestInformation(lPatch[4])\n                addTextCombined(layer, font, calibText, lx, ly + 20, colorLowest)\n            end\n\n            if closestFlower.flower and flower.name == closestFlower.flower and closestFlower.distance < 5000 and closestFlower.patch == lPatch[1] then\n                drawHex(lx, ly, flowerHexSize * 0.95, 0.5)\n            end\n\n            if lPatch[3] then\n                addTextCombined(layer, font, round(lPatch[4][1], 2) .. \"%\", lx, ly, colorLowest)\n                addTextCombined(layer, font, secondsToClockString(getArkTime() - lPatch[3], true), lx, ly + 50, cyanColor, 0.1, nil, AlignV_Bottom)\n            end\n\n            addTextCombined(layer, font, formatDistance(lPatch[5]), lx, ly + 70, cyanColor, 0.1, nil, AlignV_Bottom)\n\n            if cReleased and insideHex(lx, ly) and not deleteAction.fn then\n\n                addTextCombined(layer, font, flower.name, rx / 2, ry - 20, cyanColor)\n\n                local out = {}\n                out.type = \"patch\"\n                out.flower = flower.name\n                out.patch = lPatch[1]\n                out.t = math.random(0, 10000)\n                patch = {}\n                setOutput(serialize(out))\n                menuNumber = menuNumber + 1\n            end\n        end\n    end\n\n    if flower.name then\n        addTextCombined(layer, bigFont, flower.name, 10, 18, cyanColor, 0.5, AlignH_Left)\n    end\n\n    if flower.c then\n        addTextCombined(layer, bigFont, flower.c[1] .. \"T  \" .. flower.c[2] .. \"KL\", rx / 2 + 10, 18, cyanColor, 0.5)\n    end\n\n    createDeleteIcon(rx - (destinationIconSize * 0.6) - 10, 10, destinationIconSize * 0.6, destinationIconSize * 0.6)\n    createDestinationIcon(rx - 10 - destinationIconSize, ry - 10 - destinationIconSize, destinationIconSize, destinationIconSize)\n    drawBackButton(10, ry - 10 - 50, 100, 50)\nend\n\nlocal smallContainerWidth = 150\nlocal smallContainerHeight = 10\n\nfunction showSmallContainerBarCentered(x, y, percent)\n\n    set(layer, nil, 1, cyanColor, 1, 1)\n\n    addBox(layer, x - (smallContainerWidth / 2), y, smallContainerWidth, smallContainerHeight)\n\n    set(layer, yellowColor, 1, nil, 1, 1)\n    setNextFillColor(layer, yellowColor.r, yellowColor.g, yellowColor.b, 1)\n    addBox(layer, x - (smallContainerWidth / 2) + 1, y + 1, smallContainerWidth * percent - 2, smallContainerHeight - 2)\nend\n\nfunction showContainerContents()\n    if not container then\n        return\n    end\n\n    if not container.mass or not container.vol or not container.maxVol then\n        return\n    end\n\n    local containerCenterY = ry - containerBarHeight - lineSideGap\n    local containerStartX = rx / 2 - (containerBarWidth / 2)\n\n    local mass = round(container.mass / 1000, 2)\n    local volume = container.vol\n    local percent = (volume / container.maxVol)\n    \n    if percent > 1 then\n        percent = 1\n    end\n    \n    set(layer, nil, 0, cyanColor, 1, 1)\n    addBox(layer, containerStartX, containerCenterY, containerBarWidth, containerBarHeight)\n\n    set(layer, yellowColor, 1, nil, 0, 1)\n    addBox(layer, containerStartX, containerCenterY, containerBarWidth * percent, containerBarHeight)\n\n    addTextCombined(layer, font, \"VOLUME\", containerStartX + 10, containerCenterY - 5, cyanColor, 0.5, AlignH_Left, AlignV_Bottom)\n\n    sx, sy = getTextBounds(font, \"VOLUME\")\n\n    addTextCombined(layer, font, mfloor((percent * 100) + 0.5) .. \"%\", containerStartX + 10 + sx + 5, containerCenterY - 5, yellowColor, 1, AlignH_Left, AlignV_Bottom)\n\n    sx, sy = getTextBounds(font, mass .. \"T\")\n\n    addTextCombined(layer, font, \"MASS\", (rx / 2) + (containerBarWidth / 2) - 10 - sx - 5, containerCenterY - 5, cyanColor, 0.5, AlignH_Right, AlignV_Bottom)\n    addTextCombined(layer, font, mass .. \"T\", (rx / 2) + (containerBarWidth / 2) - 10, containerCenterY - 5, yellowColor, 1, AlignH_Right, AlignV_Bottom)\nend\n\n--local sliderBarHeight = 20\nlocal sliderHeight = lineHeight + 6\nlocal sliderWidth = 10\n\nfunction drawSlider(y, minerID, estimateCalib)\n\n    local hoverColor = cyanColor\n\n    if not editor.sliders then\n        slider = {}\n        editor.sliders = slider\n    end\n\n    local slider = editor.sliders[minerID]\n\n    if not slider then\n        slider = {}\n        editor.sliders[minerID] = slider\n    end\n\n    if insideArea(lineSideGap, y + 5, rx - (lineSideGap * 2), lineHeight) then\n        hoverColor = orangeColor\n    end\n\n    local sliderBarWidth = rx - (lineSideGap * 2)\n\n    if not slider.state then\n        slider.state = estimateCalib\n    end\n\n    local posX = sliderBarWidth * slider.state / 100 + (lineSideGap - (sliderWidth / 2))\n\n    local posY = y - ((sliderHeight - lineHeight) / 2)\n\n    local sliderClickColor = backgroundColor\n\n    if insideArea(0, y + 5, rx, lineHeight) then\n        if cPressed then\n            slider.pressed = true\n        end\n    end\n\n    if cReleased then\n        slider.pressed = false\n    end\n\n    if slider.pressed then\n        sliderClickColor = orangeColor\n    end\n\n    if slider.modified then\n        sliderClickColor = greenColor\n    end\n\n    setNextFillColor(layer, sliderClickColor.r, sliderClickColor.g, sliderClickColor.b, 0.5)\n\n    local color = mixColors(barColorBad, barColorGood, (slider.state - 40) / 100)\n\n    if slider.modified then\n        setNextStrokeColor(layer, color.r, color.g, color.b, 1)\n    else\n        setNextStrokeColor(layer, color.r, color.g, color.b, 0.5)\n    end\n    setNextStrokeWidth(layer, 1)\n    addBox(layer, posX, posY, sliderWidth, sliderHeight)\n\n    setNextStrokeColor(layer, cyanColor.r, cyanColor.g, cyanColor.b, 0.5)\n    setNextStrokeWidth(layer, 1)\n    addLine(layer, posX + (sliderWidth / 2), posY + 20, posX + (sliderWidth / 2), posY + sliderHeight - 20)\n\n    if slider.pressed and cX >= 0 and cX <= rx then\n        local p = cX - lineSideGap\n        slider.state = p * 100 / sliderBarWidth\n\n        if slider.state < 0 then\n            slider.state = 0\n        end\n        if slider.state > 100 then\n            slider.state = 100\n        end\n    end\n\n    if slider.state >= 99 then\n        slider.state = 100\n    end\n\n    if mabs(slider.state - estimateCalib) < 1 then\n        slider.state = estimateCalib\n        slider.modified = false\n    else\n        slider.modified = true\n    end\n\n    if slider.pressed then\n        if cX < 0 or cX > rx then\n            slider.pressed = false\n        end\n    end\n\n    editor.sliders[minerID] = slider\nend\n\nfunction isModified()\n\n    if not editor.edit then\n        return false\n    end\n\n    for pos, slider in ipairs(editor.sliders) do\n        if slider.modified then\n            return true\n        end\n    end\n    return false\nend\n\nfunction sendPatchUpdate()\n    if not isModified() then\n        return\n    end\n\n    local patchInfo = {}\n\n    patchInfo[1] = flower.name\n    patchInfo[2] = patch.name\n\n    local tempMiners = {}\n\n    for id, miner in ipairs(patch.miners) do\n\n        local rate = miner[2]\n        local calibration = miner[3]\n        local extractionTime = miner[7]\n        local playerId = miner[6]\n        local lastVolume = miner[8]\n\n        if editor.edit and editor.sliders[id] and editor.sliders[id].modified then\n            local editedCalib = mmin(editor.sliders[id].state, miner[4])\n            local calibPercent = mmin(miner[3], miner[4])\n            local maxRate = (100 * miner[2]) / calibPercent\n            rate = (maxRate * editedCalib) / 100\n\n            extractionTime = 0\n            calibration = editor.sliders[id].state\n            playerId = -1\n            lastVolume = 0\n        end\n\n        local data = {}\n        data[1] = miner[1] -- state\n        data[2] = rate -- Rate\n        data[3] = calibration -- calibration\n        data[4] = miner[4] -- optimal\n        data[5] = miner[5] -- efficientcy\n        data[6] = playerId -- player ID\n        data[7] = extractionTime -- extraction time\n        data[8] = lastVolume -- last Volume\n        data[9] = miner[9] -- ore ID\n\n        tempMiners[#tempMiners + 1] = data\n    end\n\n    local temp = {\n        type = \"screenEdit\",\n        p = patchInfo,\n        m = tempMiners\n    }\n\n    local container = {}\n\n    if container.mass and container.vol and container.maxVol then\n        container = { round(container.mass, 2), mfloor(container.vol) }\n        temp.c = container\n    end\n\n    setOutput(serialize(temp))\n\nend\n\nfunction saveButton(y)\n\n    local saveButonWidth = 200\n    local saveButonHeight = lineHeight * 0.6\n\n    local hoverColor = backgroundColor\n    local hoverTextColor = cyanColor\n\n    local modified = isModified()\n\n    if modified and insideArea(rx / 2 - (saveButonWidth / 2), y, saveButonWidth, saveButonHeight) then\n        hoverColor = orangeColor\n        hoverTextColor = backgroundColor\n        if cReleased then\n            sendPatchUpdate()\n        end\n    end\n\n    if modified then\n        setNextFillColor(layer, hoverColor.r, hoverColor.g, hoverColor.b, 1)\n        setNextStrokeColor(layer, cyanColor.r, cyanColor.g, cyanColor.b, 1)\n    else\n        setNextFillColor(layer, hoverColor.r, hoverColor.g, hoverColor.b, 0.1)\n        setNextStrokeColor(layer, cyanColor.r, cyanColor.g, cyanColor.b, 0.1)\n    end\n\n    setNextStrokeWidth(layer, 1)\n    addBox(layer, rx / 2 - (saveButonWidth / 2), y, saveButonWidth, saveButonHeight)\n\n    if modified then\n        addTextCombined(layer, font, \"Save\", rx / 2, y + (saveButonHeight / 2), hoverTextColor)\n    else\n        addTextCombined(layer, font, \"Save\", rx / 2, y + (saveButonHeight / 2), hoverTextColor, 0.1)\n    end\nend\n\nfunction addTitleText(text, x, y)\n    addTextCombined(layer, font, text, x, y, cyanColor, 0.8, AlignH_Center, AlignV_Bottom)\nend\n\nfunction showPatchMenu()\n\n    local layer = createLayer()\n\n    local iconX = lineSideGap + 10\n    local nameX = (lineSideGap * 2) + lineIconSize\n    local efficiencyX = lineSideGap + 150\n    local calibrationX = lineSideGap + 330\n    local rateX = lineSideGap + 500\n    local lastX = lineSideGap + 650\n    local nextX = lineSideGap + 800\n    local ccal = lineSideGap + 920\n    local statusX = rx - lineSideGap - 20\n\n    local offsetY = 5\n\n    local lry = offsetY\n\n    local difInTime = mfloor(getTime() - lastDataUpdate)\n    local fromLastUpdate = 0\n\n    if patch.time then\n        fromLastUpdate = (currentTime + difInTime) - patch.time\n        addTextCombined(layer, font, \"Last update: \" .. secondsToClockString(getArkTime() - patch.time, true), rx / 2, ry - containerBarHeight - lineSideGap, cyanColor, 0.8, AlignH_Center, AlignV_Bottom)\n    end\n\n    local lineSpacing = lineSpacing\n\n    if patch.miners then\n        local records = false\n        for pos, miner in ipairs(patch.miners) do\n\n            if patch.time then\n                records = true\n                local estimateCalib = estimateCalibration(miner[3], miner[7], patch.time, false)\n\n                lry = (pos * lineHeight) + (pos * lineSpacing) + offsetY\n\n                if editor.edit then\n                    drawSlider(lry - (lineHeight / 2), pos, estimateCalib)\n                end\n\n                set(layer, nil, 0.6, cyanColor, 1, 0.01)\n\n                if not editor.edit and insideArea(lineSideGap, lry - (lineHeight / 2), rx - (lineSideGap * 2), lineHeight) and not deleteAction.fn then\n                    setNextStrokeColor(layer, orangeColor.r, orangeColor.g, orangeColor.b, 1)\n                    setNextFillColor(layer, uiSettings.r, uiSettings.g, uiSettings.b, 0.5)\n\n                    if cReleased then\n                        set(layer, orangeColor, 0.6, cyanColor, 1, 0.01)\n\n                        setOutput(serialize({ type = \"location\", id = pos, patch = patch.name, fn = flower.name }))\n                    end\n                end\n\n                addBox(layer, lineSideGap, lry - (lineHeight / 2), lineWidth, lineHeight)\n                local m = miner[9];\n                addImage(layer, getOreImage(miner[9], patch.ores[m][2]), iconX, lry - (lineIconSize / 2), lineIconSize, lineIconSize)\n\n                if estimateCalib and miner[3] and miner[2] and miner[3] > 0 then\n\n                    if editor.edit and editor.sliders[pos] and editor.sliders[pos].modified then\n                        addTextCombined(layer, bigFont, round((((100 * miner[2]) / mmin(miner[3], miner[4])) * mmin(editor.sliders[pos].state, miner[4])) / 100, 2) .. \"L\", rateX, lry, greenColor)\n                    else\n                        addTextCombined(layer, bigFont, round((estimateCalib / miner[3]) * miner[2], 2) .. \"L\", rateX, lry)\n                    end\n                end\n\n                if miner[7] > 0 and miner[7] + fromLastUpdate < 60 * 60 * 24 * 365 then\n                    -- Last\n                    addTextCombined(layer, font, miner[10], lastX, lry - (lineHeight / 4))\n\n                    if miner[8] == -1 then\n                        addTextCombined(layer, font, \"Manual\", lastX, lry + (lineHeight / 4))\n                    else\n                        addTextCombined(layer, font, miner[8] .. \"L\", lastX, lry + (lineHeight / 4))\n                    end\n                end\n\n                addTextCombined(layer, font, miner[5] .. \"% | \" .. miner[4] .. \"%\", efficiencyX, lry)\n\n                if miner[7] > 0 then\n                    -- Next calibration indicator\n                    local nextCalTime = timeUntilReCalibration(estimateCalib, miner[7], patch.time, mmin(miner[4], minimalCalibration))\n\n                    if editor.edit and editor.sliders[pos] and editor.sliders[pos].modified then\n                        nextCalTime = timeUntilReCalibration(editor.sliders[pos].state, 0, getArkTime(), mmin(miner[4], minimalCalibration))\n                        setNextFillColor(layer, greenColor.r, greenColor.g, greenColor.b, 1)\n                    end\n                    if nextCalTime < 0 then\n                        nextCalTime = \"Calibrate!\"\n                    else\n                        nextCalTime = secondsToClockString(nextCalTime, true)\n                    end\n                    setNextTextAlign(layer, AlignH_Center, AlignV_Middle)\n                    addText(layer, font, nextCalTime, nextX, lry)\n                end\n\n                if miner[7] > 0 and miner[7] + fromLastUpdate < 60 * 60 * 24 * 365 then\n                    -- Calibration\n                    if editor.edit and editor.sliders[pos] and editor.sliders[pos].modified then\n                        addTextCombined(layer, font, \"-\", calibrationX, lry, greenColor)\n                    else\n                        addTextCombined(layer, font, secondsToClockString(miner[7] + fromLastUpdate, true), calibrationX, lry)\n                    end\n                end\n\n                if miner[7] > 0 and miner[7] + fromLastUpdate < 60 * 60 * 24 * 365 then\n                    -- Current Calibration\n                    if editor.edit and editor.sliders[pos] and editor.sliders[pos].modified then\n                        addTextCombined(layer, font, round(editor.sliders[pos].state, 2) .. \"%\", ccal, lry, greenColor)\n                    else\n                        addTextCombined(layer, font, round(estimateCalib, 2) .. \"%\", ccal, lry)\n                    end\n                end\n\n                local fillColor = cyanColor\n                if miner[1] > 1 then\n                    if miner[1] == 2 then\n                        fillColor = greenColor\n                    elseif miner[1] == 3 or miner[1] == 4 then\n                        fillColor = redColor\n                    end\n                end\n                setNextFillColor(layer, fillColor.r, fillColor.g, fillColor.b, 1)\n                addCircle(layer, statusX, lry, 10)\n\n                local color = mixColors(barColorBad, barColorGood, (estimateCalib - 40) / 100)\n\n                local width = estimateCalib * lineWidth / 100\n\n                if width > 1 then\n\n                    set(layer, color, 1, nil, 0, 0)\n\n                    addBox(layer, lineSideGap, lry + (lineHeight / 2) - 5, width, 5)\n\n                    set(layer, color, 1, nil, 0, 0)\n                    addBox(layer, lineSideGap, lry - (lineHeight / 2), width, 5)\n\n                    set(layer, color, 0.05, nil, 0, 0)\n                    addBox(layer, lineSideGap, lry - (lineHeight / 2) + 5, width, lineHeight - 10)\n                end\n            end\n\n        end\n\n        if editor.edit then\n            saveButton(lry + (lineHeight / 2) + lineSpacing)\n        end\n\n        if records then\n            lry = (lineHeight / 2) + lineSpacing - 10 + offsetY\n\n            addTitleText(\"Rate\", rateX, lry)\n            addTitleText(\"Last Calibration\", calibrationX, lry)\n            addTitleText(\"Calibrated By\", lastX, lry)\n            addTitleText(\"Next calibration\", nextX, lry)\n            addTitleText(\"Efficiency\", efficiencyX, lry - 10)\n            addTitleText(\"Optimal\", efficiencyX, lry + 10)\n            addTitleText(\"Current\", ccal, lry)\n        end\n    end\n\n    showContainerContents()\n\n    if #flower > 0 or #flowers > 0 then\n\n        createEditIcon(10, 10, destinationIconSize * 0.8, destinationIconSize * 0.8)\n\n        createDeleteIcon(rx - (destinationIconSize * 0.6) - 10, 10, destinationIconSize * 0.6, destinationIconSize * 0.6)\n        createDestinationIcon(rx - 10 - destinationIconSize, ry - 10 - destinationIconSize, destinationIconSize, destinationIconSize)\n        drawBackButton(10, ry - 10 - 50, 100, 50)\n    end\nend\n\nif menuNumber == 1 then\n    showFlowers()\nelseif menuNumber == 2 then\n    showFlowerMenu()\nelse\n    showPatchMenu()\nend\n\nfunction drawBox()\n    set(layer, nil, 0, cyanColor, 1, 0.1)\n    addBox(layer, 5, 5, rx - 10, ry - 10)\nend\ndrawBox()\n\ndrawDeleteConfirmation()\ndrawAliveOverlay()\nrequestAnimationFrame(1)\n]]\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"12"}],"methods":[],"events":[]}
